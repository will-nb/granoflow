# Codex Rules for GranoFlow Project
# Curated from .cursor/rules for Codex agent usage

# =============================================================================
# 00-global.mdc - Global Rules
# =============================================================================

- 变更最小：只修 blocker + 当前里程碑必需。
- 必须规格先行：每个变更先提交 `documents/` 下的相关文档。
- CI 门禁：必须通过 `flutter analyze` 与 `flutter test`（具体细则由 `analysis_options.yaml` 保障）。
- 页面/Widget 禁止在 `build` 触发副作用（网络/存储/导航）。
- 文案本地化：禁止硬编码用户可见字符串，统一使用 l10n（`flutter gen-l10n`）。
- 新代码必须附最小测试（happy + error）。
- 受保护路径见文档中的配置说明。

### 单行忽略（lint）规范
- 仅在无法通过合理重构或上下文检查满足 lint 时，允许"单行忽略"。
- 必须在同一行追加中文理由，说明为何可安全忽略、已做何防护。
- 示例：
  ```dart
  // ignore: use_build_context_synchronously // 理由：已在上一行 mounted 检查，避免跨异步gap使用context
  ```

### 规格模板与路径
- 变更需先提交前端规格：使用 `documents/` 目录下的相应文档格式。
- 路径规范：`documents/spec/YYMMDD-<module>/` 目录结构。

### 局部产品设计触发（design）
- 当功能尚无明确设计时，用户以 `design` 开头提出需求，助手需先进入局部产品设计讨论。
- 讨论输出采用 `documents/spec/` 下的 YAML 文档，基于 `documents/templates/design_template.yaml`。
- 文档存放路径建议：`documents/spec/<module>/design/YYMMDD-<slug>.yaml`，其中 `<slug>` 用于同日多次迭代区分。
- 设计阶段只描述功能目标、用户流程与呈现，不讨论技术实现；经用户确认后再进入 `plan/update_plan` 流程。
- 每次完成 design 文档并获得确认后，需主动提醒用户创建对应的 iteration 蓝图文档（拼写：`iteration`）。

### 迭代蓝图（plan 前置）
- 设计确认后，进入 `plan` 前需编写迭代蓝图，梳理代码范围、数据模型、测试与文档变更。
- 蓝图采用 `documents/templates/iteration_template.yaml` 模板，归档建议：`documents/spec/<module>/iteration/YYMMDD-<slug>.yaml`，与 design 保持一一对应。
- 蓝图明确风险与验证清单，为 `plan/update_plan` 拆解提供依据。

## YAML 文档约束系统
- `documents/` 下的文档是代码的"设计契约"（Design Contract），用于锁定架构版本，防止 AI 修改偏离既定设计
- **修改代码前必读**：修改任何被文档描述的文件前，必须先读取对应的文档理解设计意图
- **契约优先原则**：如果代码实现和文档描述不一致，优先以文档为准；如果文档描述不合理，应停下来讨论而非自行修改
- **同步更新要求**：重构后必须同步更新对应的文档；如果文件被拆分/删除，对应的文档也要更新/删除
- **文档类型与位置**：
  - `documents/spec/` - 规格设计契约（产品需求、用户故事、技术规范）
  - `documents/config/` - 配置设计契约（主题、环境、本地化、代码规范）
  - `documents/architecture/` - 架构设计契约（组件、数据流、状态管理）
  - `documents/project/` - 项目管理契约（计划、进度、规则、KPI）
  - `documents/plan/` - 迭代执行契约（预览和详细计划）
  - `documents/deployment/` - 部署设计契约（上线、迁移、发布）
  - `documents/legal/` - 法律合规契约（隐私、服务条款）

## 版本控制策略
- **时间触发条件**：比对和上次递交是否超过半小时，超过半小时则提交，否则只用pre-commit验证代码质量。
- **规则同步要求**：当rules发生修改时，`.cursor/rules`和`documents/rules.yaml`应该保持同步。
- 如果没有明确的rules要求`git push`，那就不进行 `git push`，大多数`git commit`都是不需要立刻`git push`的。
- 如果本次修改的只有markdown文件或mdc文件，则不要自动`git commit`,除非用户主动要求或与其他rules相抵触。

## flutter analyze（静态分析）报错和flutter test报错
  - 打开并读取报错的文件，阅读整个代码文件；
  - 分析原因，用打比方举例子的方式进行尽可能通俗的解释。
  - 提出修改意见，包括1:要修改的文件；2.行号；3.原内容；4.修改内容
  - 如果修改量不大，直接修改，如果要改超过三个文件，停下来等待我确认后再继续
  - 修改完成后，判断当前修改用单元测试验证合适还是集成测试合适，看看当前测试是否需要修改，然后执行测试。
  - 我说的集成测试是指项目根目录下的integration_test，直接用macos测试这样就不用连接手机了
  - 测试全部通过后进行flutter analyze进行测试，同样要保证所有failed和error都必须解决，不可绕过递交
  - 所有warning和info请自行判断是按提示解决还是直接屏蔽
  - 通过后git commit提交，但是不要push
  - 到此修改完成

### 界面与交互规则
- 未经用户确认，助手不得修改UI表现。
- 助手在编写任何代码时，如果发现设计存在潜在优化空间（包括 UI 表现、API 契约、交互流程），必须先提出 改进建议，明确说明：
  - 参考的大厂或官方规范；
  - 变更的预期收益；
  - 潜在的影响范围。
- 如果改动没有带来 明显且可度量的收益，应避免调整，保持现状。

### 防止编译错误
如果写代码时遇到flutter analyze或flutter run报错，应该要阅读相关的g.dart文件，精确调用当前版本。这种库经常更新，你所知的版本未必适合我们。

### 重构原则（强制执行，不可绕过）

#### 文件行数限制（硬性阈值）
- **lib/presentation/** 下的每个 dart 文件：**最大 500 行**（警告阈值 400 行）
- **lib/core/utils/**、**lib/core/providers/**、**lib/core/services/**、**lib/core/monetization/** 下的 dart 文件：**最大 400 行**（警告阈值 300 行）
- **lib/data/repositories/** 下的每个 dart 文件：**最大 500 行**（警告阈值 400 行）
- **lib/main.dart**：**最大 100 行**（警告阈值 80 行）
- **lib/data/models/** 下的每个 dart 文件：**最大 300 行**（警告阈值 250 行）
- **lib下每个方法**：**最大 60 行**（警告阈值 50 行）

#### 开发新功能时的强制检查流程（必须执行）

**步骤 1：修改前检查**
在编写或修改任何代码前，必须先检查目标文件的当前行数：
- 如果文件当前行数 ≥ 警告阈值，**必须先重构再添加新功能**
- 如果文件当前行数 < 警告阈值，但添加新代码后会超过阈值，**必须先拆分再添加新功能**

**步骤 2：预估代码量**
在添加新功能前，预估将增加的代码行数：
- 如果预估新增代码会让文件超过警告阈值（即使未超过硬性阈值），**必须提前拆分**
- 一次新增超过 100 行的代码，**必须拆分到新文件**

**步骤 3：拆分策略**
如果文件需要拆分，按以下优先级拆分：
1. **按职责拆分**：将不同职责的方法拆分到不同文件
   - Repository：查询方法 → `*_queries.dart`，变更方法 → `*_mutations.dart`，Stream 方法 → `*_streams.dart`
   - Widget：子组件 → 独立的 `*_widget.dart` 文件
   - Provider：按功能模块拆分到独立的 `*_provider.dart` 文件
   - Service：按业务领域拆分到独立的 `*_service.dart` 文件

2. **按层次拆分**：将不同抽象层次拆分
   - 接口定义 → `*_interface.dart` 或 `*_base.dart`
   - 实现类 → `*_impl.dart` 或具体实现文件

3. **按功能拆分**：将相关功能聚合到新文件
   - 相关的方法和辅助函数放在一起
   - 保持内聚性，避免过度碎片化

**步骤 4：重构执行**
- 重构必须在添加新功能**之前**完成，不得先添加代码再重构
- 重构后必须运行测试确保功能正常：`flutter test`
- 重构后必须更新相关文档（YAML 文档）
- 重构后文件大小必须在阈值范围内

**步骤 5：完成检查**
添加新功能后，再次检查文件行数：
- 如果超过硬性阈值，**立即停止，必须重构后才能继续**
- 如果接近警告阈值，**记录警告，下次修改前必须重构**

#### 新文件创建规则
- 创建新文件时，如果初始代码就超过 300 行，**必须拆分成多个文件**
- 新文件的初始代码应该控制在 200 行以内，为后续扩展留出空间

#### 重构触发条件（任一满足即触发）
1. ✅ 文件行数超过硬性阈值
2. ✅ 文件行数超过警告阈值且需要添加新功能
3. ✅ 预估新增代码会让文件超过警告阈值
4. ✅ 方法超过 60 行
5. ✅ 一次提交新增超过 100 行代码到单个文件

#### 重构优先级
1. **P0（立即重构）**：文件超过硬性阈值，阻止所有新功能开发
2. **P1（优先重构）**：文件超过警告阈值，在添加新功能前必须重构
3. **P2（计划重构）**：文件接近警告阈值，在下次修改前重构

#### 重构豁免条件（仅限特殊情况）
以下情况可以暂时豁免，但必须在代码注释中说明理由：
- 生成的代码文件（*.g.dart）不需要拆分
- 明确的临时文件，且有明确的重构计划和时间表
- 需要特殊说明的技术原因（必须在注释中详细说明）

**豁免格式：**
```dart
// 重构豁免：此文件包含 [具体原因]，计划在 [日期] 前重构为 [拆分方案]
// 当前行数：[行数]，警告阈值：[阈值]
```

#### AI 助手的工作流程
当用户要求添加新功能时，AI 必须：
1. **检查目标文件行数**（使用 `wc -l` 或读取文件统计）
2. **预估新增代码量**
3. **判断是否需要重构**
4. **如需要重构**：
   - 先向用户说明需要重构的原因
   - 提出拆分方案
   - 执行重构
   - 运行测试验证
   - 然后添加新功能
5. **如不需要重构**：
   - 添加新功能
   - 再次检查文件行数
   - 如果超过阈值，立即重构

**违反此规则的行为视为严重错误，必须立即纠正。**

# =============================================================================
# 10-style-dart.mdc - Dart Style Rules
# =============================================================================

- 命名：类 UpperCamelCase，成员 lowerCamelCase，文件 snake_case。
- 控制流：早返回；空安全优先；避免深嵌套。
- 日志：使用适当的日志记录方式，避免 print（测试目录除外）。
- 静态检查零容忍（analyzer 无 info/warn）：
  - no_leading_underscores_for_local_identifiers：本地变量、函数名不以下划线开头（以下划线表示库私有，不适用于局部标识符）。
  - unintended_html_in_doc_comment：文档注释内避免使用尖括号 <...>；若需展示占位符，使用 `{name}` 或 `[...]`。
  - unused_element / dead_code：删除未使用的方法、变量、导入；或在更合适位置使用。
  - asset_does_not_exist：pubspec 中不声明不存在的资产或目录；可选资产以运行时 try/catch 读取，不入 pubspec。
  - prefer_const_* / unnecessary_*：在不影响可读性的前提下，遵循 lints 提示优化。

## 资产与可选资源声明
- 仅将"确定存在、版本受控"的资产写入 pubspec.yaml；可选/运行时生成的文件（如种子数据）不得写入 pubspec 以免打包失败。
- 运行时可选加载必须使用 try/catch 包裹，缺失时静默降级（不抛异常、不打印错误）。

## 文档注释与代码注释
- 避免在 dartdoc 中使用 `<tag>` 形式；统一使用 `{tag}` 或 `\\<tag\\>` 转义。
- 注释描述"为什么"，避免解释"如何"。

## 命名与可读性
- 局部变量、局部函数名不得以下划线 `_` 开头；库私有成员才使用 `_` 前缀。
- 使用完整单词，避免晦涩缩写；对评分/排序等逻辑使用含义明确的函数名（如 `scoreFor`, `top3For`）。

## 目录：
  - `lib/core/` 应用配置、共享工具、主题、状态管理
  - `lib/data/` 数据模型、仓库、服务
  - `lib/presentation/` UI 组件、页面、路由
- 分析/格式：具体 lint 由 `analysis_options.yaml` 统一保障，此处不赘述具体条目。
- 提交信息：`type(scope): subject`。

# =============================================================================
# 11-development-workflow.mdc - Development Workflow
# =============================================================================

## 功能开发流程

### 1. 分支准备
```bash
# 创建功能分支
git switch -c feature/YYMMDD-<short-description>
```

### 2. 测试先行（Red → Green）
- 在 `test/unit/` 编写最小失败用例
- 运行测试确保先红：
  ```bash
  flutter test test/unit -r compact
  ```

### 3. 最小实现
- 实现功能使测试通过
- 遵循代码规范和架构原则
- 本地验证：
  ```bash
  flutter analyze
  flutter test test/unit -r compact
  ```

### 4. 提交规范
```bash
# 单次提交格式
git commit -m "feat(scope): 简短描述功能

- 详细说明变更内容
- 涉及的文件或模块
- 相关测试用例"
```

## Bug 修复流程

### 1. 分支准备
```bash
# 创建修复分支
git switch -c fix/YYMMDD-<short-description>
```

### 2. 编写复现用例（先红）
- 在 `test/unit/` 编写能稳定复现问题的测试
- 确保测试失败（红色）
- 如果测试通过，说明复现用例不够准确，继续完善

### 3. 最小修复
- 以最小变更修复问题
- 避免"顺便优化"或扩大影响范围
- 遵循代码规范

### 4. 防回归测试
- 保留复现用例作为回归测试
- 补充边界条件和异常场景测试
- 确保覆盖问题根因

### 5. 提交规范
```bash
# 提交格式
git commit -m "fix(scope): 简短描述问题

问题现象：
- 具体的错误表现

根本原因：
- 问题的根本原因分析

修复方案：
- 采取的修复措施
- 影响范围评估

测试：
- 复现用例路径
- 回归测试覆盖"
```

## 质量门禁
- ✅ `flutter analyze` 无错误
- ✅ `flutter test test/unit` 通过
- ✅ 新增代码有对应测试
- ✅ 复现用例从失败变为通过（修复场景）

## 停机-回顾触发器
以下情况立即停止并复盘：
- 连续 3 次同一测试失败
- 连续 3 次 `flutter analyze` 不通过
- 实现与预期明显偏离
- 修复与预期不符

固定动作：
```bash
# 创建 checkpoint
git add -A && git commit -m "chore: checkpoint for review"
```

## 注意事项
- 详细的 commit message 即为最好的文档
- 按实际需要补充注释说明复杂逻辑

# =============================================================================
# 17-ci-cd-workflow.mdc - CI/CD Workflow
# =============================================================================

## 代码质量门禁
- 必须通过 `flutter analyze` 与 `flutter test`
- 必须通过 `dart format` 格式化检查
- 禁止遗留调试代码（print、debugPrint、TODO、FIXME）

## Pre-commit 钩子
- 运行 `flutter analyze`
- 扫描 `lib/` 目录中的调试代码
- 检查高优先级 TODO/FIXME

## Pre-push 钩子
- 验证构建（Android APK + iOS 无签名）
- 运行单元测试和组件测试
- 最终扫描遗留调试代码

## 构建验证
- Android: `flutter build apk --debug`
- iOS: `flutter build ios --no-codesign`
- Web: `flutter build web`

## 测试策略
- 单元测试：`flutter test test/unit`
- 组件测试：`flutter test test/presentation`
- 集成测试：`flutter test integration_test -d macos`

# =============================================================================
# 50-testing.mdc - Testing Rules
# =============================================================================

- 分层：unit（纯 Dart）、widget（关键组件）、integration（端到端）。
- 远程依赖：全部 mock；单元测试不连接真实服务。
- 遵循 `analysis_options.yaml` 的分析规则。

## 常用测试命令
```bash
flutter test test/unit -r compact
flutter test test/presentation -r compact
flutter test integration_test -d macos
```

## 单元测试调试流程
**⚠️ 说明：此规则仅适用于单元测试调试。不连接真实服务器/设备/第三方。**

### 执行步骤
1) 标记上下文：输出"开始调试单元测试问题"。
2) 收集信息：从对话与上下文提取测试文件与报错；信息不足则执行测试获取详细信息。
3) 分析：列出报错文件与行上下文、可能原因（代码缺陷/测试用例/fixture）。
4) 解释：用通俗语言说明错误本质与知识点。
5) 决策：修代码/改测试/移除不必要测试（三选一，给出理由）。
6) 修改并重跑：
   ```bash
   flutter analyze && flutter test {测试文件名} -r compact -v
   ```
7) 重试上限：同一测试文件最多 3 次；若无进展，停止该文件调试并恢复到最接近正确的状态。
8) 小结：说明问题根因、有效修改与当前结果。

## 失败阈值与停机-回顾
- 同一测试用例连续失败 ≥ 3 次：触发停机-回顾流程，先 checkpoint 再复盘与回退/再立项。
