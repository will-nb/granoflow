{
  // ===========================================
  // 任务清单页面增强设计文档
  // 增强任务清单页面的交互体验：长按拖拽、Checkbox 状态切换、今日区域显示已完成任务
  // 适用范围：任务清单（Tasks）页面的所有区域
  // ===========================================
  
  // ===========================================
  // 1. 整体设计理念（必填）
  // ===========================================
  designPhilosophy: {
    // 设计目标：提升任务清单页面的交互体验，简化操作流程
    goal: "增强任务清单页面的交互体验：1) 移除拖拽手柄，支持长按任意位置拖拽；2) 添加 Checkbox 快速切换任务完成状态；3) 在今日区域显示已完成任务，提供更完整的今日任务视图",
    
    // 主题集成：与现有 Ocean Breeze 主题保持一致
    themeIntegration: {
      // 一致性：保持与现有主题一致的部分
      consistency: [
        "使用 Ocean Breeze 配色方案（海盐蓝、薄荷青、湖光青等）",
        "复用现有的 Checkbox 样式（Material 3 Checkbox，使用主题主色）",
        "遵循现有的任务行布局规范（水平布局、间距、内边距）",
        "保持与现有任务状态切换逻辑的一致性（使用 TaskStatusToggleHelper）",
        "保持现有的拖拽排序功能（ReorderableListView）",
      ],
      
      // 创新点：与现有设计不同的设计突破
      innovation: [
        "长按拖拽：移除拖拽手柄，支持长按任务行任意位置启动拖拽，提升操作便利性",
        "Checkbox 快速切换：在任务行前添加 Checkbox，提供快速完成/恢复任务的交互方式",
        "今日区域增强：在今日区域同时显示未完成和已完成任务，提供更完整的今日任务视图",
        "视觉区分：已完成任务使用删除线，清晰区分任务状态",
      ],
    },
    
    // 设计趋势：参考的设计趋势或风格
    trends: [
      "长按拖拽：主流任务管理应用（Things 3、Todoist）支持长按拖拽，提升操作便利性",
      "Checkbox 快速切换：Checkbox 是任务管理应用的标准交互方式，用户认知成本低",
      "今日视图增强：在今日区域显示已完成任务，帮助用户回顾今日完成情况",
      "视觉反馈：使用删除线清晰区分已完成任务，符合用户认知习惯",
    ],
  },

  // ===========================================
  // 2. 配色方案（必填）
  // ===========================================
  colorScheme: {
    // Checkbox 配色
    checkbox: {
      // 选中状态颜色
      checkedColor: {
        light: "Theme.of(context).colorScheme.primary", // 海盐蓝 (0xFF6EC6DA)
        dark: "Theme.of(context).colorScheme.primary", // 湖光青 (0xFF4FAFC9)
        note: "使用主题主色，与现有主题保持一致",
      },
      // 未选中状态边框颜色
      uncheckedColor: {
        light: "Theme.of(context).colorScheme.outline", // 轮廓色
        dark: "Theme.of(context).colorScheme.outline", // 轮廓色
        note: "使用主题的 outline 颜色，确保在不同模式下都有良好的可见性",
      },
      // 选中状态背景颜色
      fillColor: {
        light: "MaterialStateProperty.resolveWith((states) { if (states.contains(MaterialState.selected)) return Theme.of(context).colorScheme.primary; return null; })",
        dark: "MaterialStateProperty.resolveWith((states) { if (states.contains(MaterialState.selected)) return Theme.of(context).colorScheme.primary; return null; })",
        note: "使用 Material 3 Checkbox 的默认填充逻辑，选中时使用主题主色",
      },
      // 选中状态勾选标记颜色
      checkColor: {
        light: "Theme.of(context).colorScheme.onPrimary", // 主色上的文字颜色
        dark: "Theme.of(context).colorScheme.onPrimary", // 主色上的文字颜色
        note: "使用 onPrimary 颜色，确保勾选标记在主题主色背景上有良好的对比度",
      },
    },
    
    // 已完成任务文字颜色
    completedTaskText: {
      light: "Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)",
      dark: "Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)",
      note: "已完成任务使用降低透明度的文字颜色，配合删除线提供清晰的视觉区分",
    },
    
    // 删除线颜色
    strikethrough: {
      light: "Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)",
      dark: "Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)",
      note: "删除线颜色与已完成任务文字颜色一致，确保视觉统一",
    },
  },

  // ===========================================
  // 3. UI 布局与组件结构（必填）
  // ===========================================
  layout: {
    // 任务行布局
    taskRow: {
      // 布局方向
      direction: "horizontal",
      // 对齐方式
      alignment: {
        mainAxisAlignment: "start",
        crossAxisAlignment: "center",
      },
      // 组件顺序（从左到右）
      components: [
        "checkbox", // Checkbox（24dp × 24dp）
        "spacing", // 间距（12dp）
        "taskTitle", // 任务标题（Expanded）
      ],
      // 内边距
      padding: {
        horizontal: 0, // dp（由外层容器控制）
        vertical: 12, // dp
      },
      // 组件间距
      spacing: {
        checkboxToTitle: 12, // dp（Checkbox 和任务标题之间的间距）
      },
    },
    
    // Checkbox 规格
    checkbox: {
      // 尺寸
      size: 24, // dp × 24dp（Material 3 标准尺寸）
      // 位置
      position: "leading", // 任务行左侧
      // 交互区域
      hitTestSize: 40, // dp × 40dp（扩大点击区域，提升可用性）
      note: "使用 Material 3 Checkbox，尺寸为 24dp × 24dp，但点击区域扩展到 40dp × 40dp",
    },
  },

  // ===========================================
  // 4. 交互流程与行为（必填）
  // ===========================================
  interactions: {
    // 长按拖拽
    longPressDrag: {
      // 触发方式
      trigger: "longPress", // 长按任务行任意位置
      // 拖拽范围
      scope: "taskRow", // 整个任务行都可以触发拖拽
      // 拖拽手柄
      dragHandle: {
        enabled: false, // 移除拖拽手柄
        note: "使用 ReorderableListView 的长按功能，无需拖拽手柄",
      },
      // 拖拽反馈
      feedback: {
        type: "ReorderableProxyDecorator", // 使用现有的拖拽代理装饰器
        note: "拖拽时显示任务行的半透明副本，提供视觉反馈",
      },
      // 拖拽限制
      constraints: {
        // 只有根任务可以拖拽排序
        rootTasksOnly: true,
        note: "只有根任务可以拖拽排序，子任务跟随父任务移动",
      },
    },
    
    // Checkbox 状态切换
    checkboxToggle: {
      // 触发方式
      trigger: "tap", // 点击 Checkbox
      // 状态切换逻辑
      stateTransition: {
        // pending -> completedActive
        pendingToCompleted: {
          action: "markCompleted",
          service: "TaskStatusService.markCompleted",
          note: "调用 TaskStatusService.markCompleted，设置 endedAt 和 dueAt 为完成时间",
          // 排序调整
          sortIndexAdjustment: {
            enabled: true,
            behavior: "moveToTopOfCompleted",
            logic: "计算已完成任务区域的最小 sortIndex，将当前任务的 sortIndex 设置为该值减 1，确保已完成任务排在未完成任务之前",
            note: "状态变为 completedActive 后，调整 sortIndex 使其排在已完成任务区域的最前面（即所有未完成任务之前）",
          },
        },
        // completedActive -> pending
        completedToPending: {
          action: "updateStatus",
          service: "TaskService.updateDetails",
          payload: "TaskUpdate(status: TaskStatus.pending)",
          note: "调用 TaskService.updateDetails，将状态恢复为 pending",
          // 排序调整
          sortIndexAdjustment: {
            enabled: true,
            behavior: "moveToBottomOfUncompleted",
            logic: "计算未完成任务区域的最大 sortIndex，将当前任务的 sortIndex 设置为该值加 1，确保未完成任务排在已完成任务之后",
            note: "状态恢复为 pending 后，调整 sortIndex 使其排在未完成任务区域的最后面（即所有已完成任务之后）",
          },
        },
      },
      // 切换反馈
      feedback: {
        type: "snackbar", // 显示 Snackbar 提示
        messages: {
          completed: "taskListTaskCompletedToast", // 本地化字符串键
          uncompleted: "taskListTaskUncompletedToast", // 本地化字符串键
        },
        duration: 2, // 秒
        note: "状态切换后显示 Snackbar 提示，使用现有的 TaskStatusToggleHelper",
      },
      // 动画效果
      animation: {
        type: "MaterialStateAnimation", // Material 3 Checkbox 默认动画
        duration: 200, // 毫秒
        note: "使用 Material 3 Checkbox 的默认动画效果",
      },
    },
    
    // 任务行点击
    taskRowTap: {
      // 触发方式
      trigger: "tap", // 点击任务行（非 Checkbox 区域）
      // 行为
      behavior: {
        // 根据任务状态显示不同的弹窗
        pending: "showTaskActionBottomSheet", // 显示任务操作弹窗
        doing: "showTaskActionBottomSheet", // 显示任务操作弹窗
        paused: "showTaskActionBottomSheet", // 显示任务操作弹窗
        inbox: "showTaskActionBottomSheet", // 显示任务操作弹窗
        completedActive: "showTaskDetailBottomSheet", // 显示任务详情弹窗（只读）
        archived: "showTaskDetailBottomSheet", // 显示任务详情弹窗（只读）
        trashed: "showTaskDetailBottomSheet", // 显示任务详情弹窗（只读）
      },
      note: "点击任务行（非 Checkbox 区域）时，根据任务状态显示相应的弹窗",
    },
  },

  // ===========================================
  // 5. 今日区域增强（必填）
  // ===========================================
  todaySectionEnhancement: {
    // 显示已完成任务
    showCompletedTasks: {
      enabled: true, // 在今日区域显示已完成任务
      // 筛选条件
      filter: {
        // 状态筛选
        status: [
          "pending", // 未完成任务
          "doing", // 进行中任务
          "paused", // 暂停任务
          "inbox", // 收集箱任务
          "completedActive", // 已完成任务（新增）
        ],
        // 其他筛选条件
        otherFilters: {
          // 项目筛选（如果启用）
          project: "preserved", // 保持现有的项目筛选逻辑
          // 标签筛选（如果启用）
          tags: "preserved", // 保持现有的标签筛选逻辑
          // 其他筛选条件
          others: "preserved", // 保持所有其他筛选条件
        },
        note: "在今日区域显示已完成任务，但其他筛选条件（项目、标签等）仍然有效",
      },
      // 排序规则
      sorting: {
        // 已完成任务在前（通过 sortIndex 控制）
        completedFirst: true,
        // 未完成任务在后（通过 sortIndex 控制）
        uncompletedLast: true,
        // 同状态内按 sortIndex 排序
        withinStatus: "sortIndex",
        // 排序逻辑
        logic: "按 sortIndex 升序排序，已完成任务的 sortIndex 小于未完成任务的 sortIndex，确保已完成任务显示在未完成任务之前",
        note: "通过 sortIndex 控制排序：已完成任务的 sortIndex 小于未完成任务的 sortIndex，确保已完成任务显示在未完成任务之前",
      },
    },
    
    // 已完成任务视觉样式
    completedTaskStyle: {
      // 删除线
      strikethrough: {
        enabled: true, // 启用删除线
        // 删除线样式
        decoration: "TextDecoration.lineThrough",
        // 删除线颜色
        color: "Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)",
        note: "已完成任务显示删除线，颜色与文字颜色一致",
      },
      // 文字颜色
      textColor: {
        color: "Theme.of(context).colorScheme.onSurface.withValues(alpha: 0.6)",
        note: "已完成任务使用降低透明度的文字颜色",
      },
      // Checkbox 状态
      checkboxState: {
        checked: true, // Checkbox 处于选中状态
        note: "已完成任务的 Checkbox 处于选中状态",
      },
    },
  },

  // ===========================================
  // 6. 关键场景与边界情况（必填）
  // ===========================================
  scenarios: {
    // 场景1：长按拖拽未完成任务
    scenario1: {
      name: "长按拖拽未完成任务",
      steps: [
        "用户在任务清单页面找到要移动的任务",
        "用户长按任务行任意位置（非 Checkbox 区域）",
        "任务行变为半透明，跟随手指移动",
        "用户将任务拖拽到目标位置",
        "松开手指，任务移动到新位置",
      ],
      expectedResult: "任务成功移动到新位置，sortIndex 和 dueAt 相应更新",
    },
    
    // 场景2：点击 Checkbox 完成任务
    scenario2: {
      name: "点击 Checkbox 完成任务",
      steps: [
        "用户在任务清单页面找到要完成的任务",
        "用户点击任务前的 Checkbox",
        "Checkbox 变为选中状态（动画效果）",
        "任务状态变为 completedActive",
        "系统计算已完成任务区域的最小 sortIndex，将当前任务的 sortIndex 设置为该值减 1",
        "任务移动到已完成任务区域的最前面（所有未完成任务之前）",
        "显示 Snackbar 提示"任务已完成"",
        "如果任务在今日区域，任务显示删除线",
      ],
      expectedResult: "任务状态成功切换为已完成，sortIndex 调整后任务移动到已完成任务区域最前面，视觉反馈清晰",
    },
    
    // 场景3：点击 Checkbox 恢复任务
    scenario3: {
      name: "点击 Checkbox 恢复任务",
      steps: [
        "用户在今日区域找到已完成的任务",
        "用户点击任务前的 Checkbox",
        "Checkbox 变为未选中状态（动画效果）",
        "任务状态变为 pending",
        "系统计算未完成任务区域的最大 sortIndex，将当前任务的 sortIndex 设置为该值加 1",
        "任务移动到未完成任务区域的最后面（所有已完成任务之后）",
        "显示 Snackbar 提示"任务已恢复"",
        "任务删除线消失",
      ],
      expectedResult: "任务状态成功恢复为未完成，sortIndex 调整后任务移动到未完成任务区域最后面，视觉反馈清晰",
    },
    
    // 场景4：今日区域显示已完成任务
    scenario4: {
      name: "今日区域显示已完成任务",
      steps: [
        "用户进入任务清单页面的今日区域",
        "系统查询所有今日的任务（包括未完成和已完成）",
        "系统按 sortIndex 升序排序所有任务",
        "已完成任务（sortIndex 较小）显示在前面",
        "未完成任务（sortIndex 较大）显示在后面",
        "已完成任务显示删除线和降低透明度的文字",
        "已完成任务的 Checkbox 处于选中状态",
      ],
      expectedResult: "今日区域同时显示未完成和已完成任务，已完成任务在前，未完成任务在后，视觉区分清晰",
    },
    
    // 边界情况1：长按 Checkbox 区域
    boundary1: {
      name: "长按 Checkbox 区域",
      behavior: "Checkbox 的点击事件优先，不会触发拖拽",
      note: "Checkbox 的点击区域（40dp × 40dp）优先处理点击事件，长按不会触发拖拽",
    },
    
    // 边界情况2：快速连续点击 Checkbox
    boundary2: {
      name: "快速连续点击 Checkbox",
      behavior: "每次点击都会触发状态切换，但会显示加载状态防止重复操作",
      note: "使用防抖或加载状态防止快速连续点击导致的状态不一致",
    },
    
    // 边界情况3：拖拽已完成任务
    boundary3: {
      name: "拖拽已完成任务",
      behavior: "已完成任务也可以拖拽排序，但只影响已完成任务内部的排序",
      note: "已完成任务可以拖拽排序，但不会影响未完成任务的位置",
    },
  },

  // ===========================================
  // 7. 技术实现要点（必填）
  // ===========================================
  implementation: {
    // 长按拖拽实现
    longPressDrag: {
      // 移除拖拽手柄
      removeDragHandle: {
        file: "lib/presentation/tasks/views/tasks_section_task_list_simplified.dart",
        action: "remove ReorderableDragStartListener wrapper",
        note: "移除 ReorderableDragStartListener 包裹的拖拽手柄图标",
      },
      // 启用长按拖拽
      enableLongPress: {
        file: "lib/presentation/tasks/views/tasks_section_task_list_simplified.dart",
        action: "use ReorderableListView default long press behavior",
        note: "ReorderableListView 默认支持长按拖拽，无需额外配置",
      },
    },
    
    // Checkbox 实现
    checkbox: {
      // 添加 Checkbox 组件
      addCheckbox: {
        file: "lib/presentation/widgets/simplified_task_row.dart",
        action: "add Checkbox widget before task title",
        component: "Checkbox",
        properties: {
          value: "task.status == TaskStatus.completedActive",
          onChanged: "TaskStatusToggleHelper.toggleTaskStatus",
          materialTapTargetSize: "MaterialTapTargetSize.shrinkWrap",
          visualDensity: "VisualDensity.compact",
        },
        styling: {
          checkColor: "Theme.of(context).colorScheme.onPrimary",
          fillColor: "MaterialStateProperty.resolveWith((states) { if (states.contains(MaterialState.selected)) return Theme.of(context).colorScheme.primary; return null; })",
        },
        note: "在 SimplifiedTaskRow 中添加 Checkbox，使用 Material 3 样式，与主题匹配",
      },
      // 调整布局
      adjustLayout: {
        file: "lib/presentation/widgets/simplified_task_row.dart",
        action: "wrap Checkbox and task title in Row",
        structure: "Row(children: [Checkbox, SizedBox(width: 12), Expanded(child: Text)])",
        note: "将 Checkbox 和任务标题包裹在 Row 中，使用 Expanded 让标题占据剩余空间",
      },
      // 排序调整逻辑
      sortIndexAdjustment: {
        file: "lib/presentation/widgets/utils/task_status_toggle_helper.dart",
        action: "modify toggleTaskStatus to adjust sortIndex after status change",
        // 使用现有的工具类
        utility: "SortIndexCalculator",
        constants: {
          defaultInterval: 1000.0, // 使用 SortIndexCalculator.defaultInterval
          minGap: 2.0, // 最小间隙阈值，小于此值需要规范化
        },
        logic: {
          pendingToCompleted: {
            step1: "在数据库事务中查询同一区域（section）的所有任务",
            step2: "筛选出已完成任务（status == completedActive）",
            step3: "如果存在已完成任务：",
            step3a: "找到最小 sortIndex（minCompletedSortIndex）",
            step3b: "使用 SortIndexCalculator.insertAtFirst(minCompletedSortIndex) 计算新 sortIndex",
            step3c: "检查间隙是否足够：如果 (minCompletedSortIndex - newSortIndex).abs() < minGap，先调用 SortIndexService.normalizeSection 规范化已完成任务区域",
            step4: "如果不存在已完成任务，使用 SortIndexCalculator.insertAtFirst(null) 或设置为一个较小的值（如 -1000）",
            step5: "在同一个事务中调用 TaskStatusService.markCompleted 更新状态和 sortIndex",
            note: "确保已完成任务的 sortIndex 小于未完成任务的 sortIndex，使用工具类避免硬编码",
          },
          completedToPending: {
            step1: "在数据库事务中查询同一区域（section）的所有任务",
            step2: "筛选出未完成任务（status != completedActive）",
            step3: "如果存在未完成任务：",
            step3a: "找到最大 sortIndex（maxUncompletedSortIndex）",
            step3b: "使用 SortIndexCalculator.insertAtLast(maxUncompletedSortIndex) 计算新 sortIndex",
            step3c: "检查间隙是否足够：如果 (newSortIndex - maxUncompletedSortIndex).abs() < minGap，先调用 SortIndexService.normalizeSection 规范化未完成任务区域",
            step4: "如果不存在未完成任务，使用 SortIndexCalculator.insertAtLast(null) 或设置为一个较大的值（如 1000）",
            step5: "在同一个事务中调用 TaskService.updateDetails 更新状态和 sortIndex",
            note: "确保未完成任务的 sortIndex 大于已完成任务的 sortIndex，使用工具类避免硬编码",
          },
        },
        // 冲突处理
        conflictHandling: {
          method: "databaseTransaction",
          description: "使用数据库事务确保 sortIndex 计算的原子性",
          implementation: "在 TaskRepository 的 updateTask 或 batchUpdate 方法中使用事务，确保查询和更新在同一事务中完成",
          note: "如果使用 Drift，可以使用 writeTransaction 确保原子性",
        },
        // 溢出处理
        overflowHandling: {
          method: "normalization",
          trigger: {
            condition: "间隙小于 minGap（2.0）时触发规范化",
            action: "调用 SortIndexService.normalizeSection 规范化整个区域",
            note: "规范化会重新分配 sortIndex，使用等差序列（start=1024, step=1024）",
          },
          periodic: {
            enabled: false, // 暂不启用定期规范化
            note: "未来可以考虑在后台定期规范化，但当前版本仅在间隙不足时触发",
          },
          boundary: {
            minValue: -1000000.0, // 最小边界值
            maxValue: 1000000.0, // 最大边界值
            action: "如果 sortIndex 接近边界，触发规范化",
            note: "边界值足够大，正常情况下不会达到，但作为安全措施保留",
          },
        },
        note: "状态切换后，根据任务状态调整 sortIndex，确保已完成任务排在未完成任务之前。使用现有工具类和规范化机制避免冲突和溢出",
      },
    },
    
    // 今日区域增强实现
    todaySectionEnhancement: {
      // 修改任务筛选逻辑
      modifyFilter: {
        file: "lib/presentation/tasks/views/tasks_section_task_list_simplified.dart",
        action: "modify task filtering logic for TaskSection.today",
        logic: "if (section == TaskSection.today) { include completedActive tasks }",
        note: "在 TaskSection.today 区域，筛选时包含 completedActive 状态的任务",
      },
      // 添加删除线样式
      addStrikethrough: {
        file: "lib/presentation/widgets/simplified_task_row.dart",
        action: "add TextDecoration.lineThrough for completed tasks in today section",
        condition: "task.status == TaskStatus.completedActive && section == TaskSection.today",
        note: "在今日区域，已完成任务显示删除线",
      },
      // 排序逻辑
      sorting: {
        file: "lib/presentation/tasks/views/tasks_section_task_list_simplified.dart",
        action: "sort tasks by sortIndex ascending (completed tasks have smaller sortIndex)",
        logic: "tasks.sort((a, b) => a.sortIndex.compareTo(b.sortIndex))",
        note: "直接按 sortIndex 升序排序，因为已完成任务的 sortIndex 小于未完成任务的 sortIndex，所以已完成任务自然排在前面",
        alternative: "如果 sortIndex 计算出现问题，可以回退到状态优先排序：tasks.sort((a, b) { if (a.status != b.status) { return a.status == TaskStatus.completedActive ? -1 : 1; } return a.sortIndex.compareTo(b.sortIndex); })",
      },
    },
  },

  // ===========================================
  // 8. 依赖与风险（必填）
  // ===========================================
  dependencies: {
    // 技术依赖
    technical: [
      "ReorderableListView 的长按拖拽功能",
      "Material 3 Checkbox 组件",
      "TaskStatusToggleHelper 状态切换逻辑",
      "TaskService 和 TaskStatusService 的状态管理",
      "SortIndexCalculator 工具类用于计算 sortIndex（使用 defaultInterval = 1000.0）",
      "SortIndexService.normalizeSection 方法用于规范化区域 sortIndex",
      "TaskRepository 用于查询同一区域的所有任务（需要在事务中查询）",
      "数据库事务支持（Drift 的 writeTransaction）确保原子性",
    ],
    
    // 数据依赖
    data: [
      "任务状态（TaskStatus）枚举",
      "任务区域（TaskSection）枚举",
      "任务数据模型（Task）",
    ],
    
    // UI 依赖
    ui: [
      "SimplifiedTaskRow 组件",
      "TasksSectionTaskListSimplified 组件",
      "Ocean Breeze 主题配色方案",
    ],
  },
  
  risks: {
    // 风险1：长按拖拽与 Checkbox 点击冲突
    risk1: {
      description: "长按 Checkbox 区域可能同时触发拖拽和点击事件",
      mitigation: "Checkbox 的点击区域（40dp × 40dp）优先处理点击事件，长按不会触发拖拽",
      severity: "low",
    },
    
    // 风险2：今日区域任务数量增加
    risk2: {
      description: "今日区域显示已完成任务后，任务数量可能显著增加，影响性能",
      mitigation: "使用虚拟滚动（ListView.builder）和懒加载，确保性能",
      severity: "medium",
    },
    
    // 风险3：状态切换失败
    risk3: {
      description: "Checkbox 状态切换可能失败（网络错误、权限问题等）",
      mitigation: "使用 try-catch 捕获错误，显示错误提示，保持 UI 状态一致",
      severity: "low",
    },
    
    // 风险4：sortIndex 计算冲突
    risk4: {
      description: "多个任务同时切换状态时，sortIndex 计算可能产生冲突（多个任务同时查询到相同的最小/最大 sortIndex）",
      mitigation: [
        "使用数据库事务（Drift 的 writeTransaction）确保查询和更新在同一事务中完成，保证原子性",
        "在事务中先查询，再计算，最后更新，避免并发冲突",
        "如果间隙不足（小于 minGap = 2.0），先规范化区域再计算，确保有足够间隙",
      ],
      severity: "medium",
      note: "数据库事务是主要解决方案，规范化是辅助措施",
    },
    
    // 风险5：sortIndex 溢出
    risk5: {
      description: "频繁切换状态可能导致 sortIndex 值不断增大或减小，最终接近边界值（double 类型的精度限制）",
      mitigation: [
        "使用 SortIndexCalculator 的 defaultInterval（1000.0）而不是简单的 +1/-1，提供更大的缓冲空间",
        "当间隙小于 minGap（2.0）时，自动触发 SortIndexService.normalizeSection 规范化整个区域",
        "规范化使用等差序列（start=1024, step=1024）重新分配 sortIndex，重置到安全范围",
        "设置边界检查（min=-1000000, max=1000000），如果接近边界则触发规范化",
      ],
      severity: "low",
      note: "规范化机制是主要解决方案，边界检查是安全措施",
    },
    
    // 风险6：规范化性能影响
    risk6: {
      description: "规范化操作需要更新整个区域的所有任务，如果区域任务数量很大，可能影响性能",
      mitigation: [
        "规范化操作在后台异步执行，不阻塞 UI",
        "规范化使用批量更新（batchUpdate）减少数据库操作次数",
        "只在间隙不足时触发规范化，避免不必要的操作",
        "如果区域任务数量超过阈值（如 1000），可以考虑局部规范化而不是全区域规范化",
      ],
      severity: "low",
      note: "正常情况下间隙足够，规范化触发频率很低，性能影响可忽略",
    },
  },

  // ===========================================
  // 9. 性能考虑（必填）
  // ===========================================
  performance: {
    // sortIndex 计算性能
    sortIndexCalculation: {
      // 查询性能
      query: {
        optimization: "在事务中查询，使用索引（section + status）加速查询",
        note: "TaskRepository.listSectionTasks 应该已经优化，使用索引查询同一区域的任务",
      },
      // 规范化性能
      normalization: {
        frequency: "低（仅在间隙不足时触发）",
        cost: "O(n) 其中 n 是区域任务数量",
        optimization: [
          "使用批量更新（batchUpdate）减少数据库操作",
          "规范化在后台异步执行，不阻塞 UI",
          "如果区域任务数量超过阈值，考虑局部规范化",
        ],
        note: "正常情况下间隙足够（defaultInterval = 1000.0），规范化触发频率很低",
      },
    },
    
    // UI 渲染性能
    uiRendering: {
      // 列表渲染
      listRendering: {
        method: "ListView.builder 或 ReorderableListView.builder（已使用）",
        optimization: "虚拟滚动，只渲染可见区域的任务",
        note: "即使今日区域任务数量增加，虚拟滚动也能保证性能",
      },
      // 状态切换动画
      animation: {
        method: "Material 3 Checkbox 默认动画（200ms）",
        optimization: "动画在 GPU 上执行，不影响主线程",
        note: "Checkbox 动画性能开销很小，可忽略",
      },
    },
  },

  // ===========================================
  // 10. 待确认问题（可选）
  // ===========================================
  openQuestions: [
    {
      question: "今日区域的已完成任务是否支持拖拽排序？",
      options: [
        "支持：已完成任务可以拖拽排序，但只影响已完成任务内部的排序",
        "不支持：已完成任务不支持拖拽排序",
      ],
      recommendation: "支持拖拽排序，但只影响已完成任务内部的排序",
    },
    {
      question: "今日区域的已完成任务是否支持左滑/右滑操作？",
      options: [
        "支持：已完成任务支持左滑/右滑操作（如归档、删除）",
        "不支持：已完成任务不支持左滑/右滑操作",
      ],
      recommendation: "支持左滑/右滑操作，保持与未完成任务的一致性",
    },
    {
      question: "其他区域（明天、本周等）是否也需要显示已完成任务？",
      options: [
        "仅今日区域：只有今日区域显示已完成任务",
        "所有区域：所有区域都显示已完成任务",
      ],
      recommendation: "仅今日区域显示已完成任务，其他区域保持现状",
    },
  ],
}

