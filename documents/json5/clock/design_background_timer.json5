{
  // 计时器后台运行与通知功能设计文档
  // 描述 Android/iOS 跨平台的后台计时、通知提醒、屏幕常亮等功能设计
  // 创建日期：2025-01-XX
  
  // ===========================================
  // 1. 整体设计理念
  // ===========================================
  designPhilosophy: {
    // 设计目标
    goal: "实现跨平台的后台计时功能，确保用户在切到后台或锁屏时仍能准确计时并收到提醒",
    
    // 核心原则
    corePrinciples: [
      "时间戳为唯一真实来源：所有计时计算基于开始时间戳，不依赖后台运行的计时器",
      "平台差异化实现：Android 使用前台服务，iOS 使用本地通知 + Live Activities",
      "用户体验一致性：两个平台的核心功能（计时准确性、到点提醒）保持一致",
      "优雅降级：在系统限制下提供最佳体验，不强制要求用户权限",
    ],
    
    // 平台策略
    platformStrategy: {
      android: {
        approach: "前台服务 + 通知栏常驻显示",
        benefits: [
          "通知栏实时显示倒计时（每秒更新）",
          "可在通知栏直接操作（暂停/结束）",
          "锁屏时通知栏可见（取决于系统设置）",
        ],
        limitations: [
          "需要用户授予通知权限（Android 13+）",
          "部分厂商可能限制后台运行（需引导用户加入白名单）",
        ],
      },
      
      ios: {
        approach: "本地通知 + Live Activities（可选）",
        benefits: [
          "到点自动提醒（本地通知）",
          "锁屏/动态岛显示实时倒计时（Live Activities，iOS 16+）",
          "无需后台常驻，符合 iOS 设计规范",
        ],
        limitations: [
          "无法在通知栏显示常驻通知（iOS 系统限制）",
          "Live Activities 需要 iOS 16+ 和额外实现",
          "切到后台后无法在通知栏操作，需打开应用",
        ],
      },
    },
    
    // 与现有功能集成
    integration: {
      withPomodoroPage: [
        "计时页面保持屏幕常亮（两个平台一致）",
        "切回前台时自动恢复计时状态",
        "暂停/继续/结束操作同步更新后台服务",
      ],
      withTimerState: [
        "基于现有的 PomodoroTimerState 和 actualRunningTime 计算",
        "状态持久化确保 App 被关闭后仍能恢复",
      ],
    },
  },

  // ===========================================
  // 2. 平台功能对比
  // ===========================================
  platformComparison: {
    // 功能矩阵
    featureMatrix: {
      // 通知栏常驻倒计时
      persistentNotificationCountdown: {
        android: true,
        ios: false,
        note: "iOS 系统不支持通知栏常驻通知",
      },
      
      // 锁屏显示倒计时
      lockScreenCountdown: {
        android: true,
        note: "通过通知栏实现，取决于系统设置",
        ios: {
          supported: true,
          requirement: "需要实现 Live Activities（iOS 16+）",
          fallback: "iOS 15 及以下仅支持到点通知，不显示实时倒计时",
        },
      },
      
      // 动态岛显示（iPhone 14 Pro+）
      dynamicIslandDisplay: {
        android: false,
        ios: {
          supported: true,
          requirement: "需要实现 Live Activities + iPhone 14 Pro 及以上机型",
        },
      },
      
      // 通知栏操作按钮
      notificationActions: {
        android: {
          supported: true,
          actions: ["暂停", "结束"],
          note: "可在通知栏直接操作，无需打开应用",
        },
        ios: {
          supported: false,
          note: "iOS 不支持在通知栏添加操作按钮（Live Activities 除外）",
        },
      },
      
      // 到点提醒通知
      completionNotification: {
        android: true,
        ios: true,
        note: "两个平台都支持，使用 flutter_local_notifications",
      },
      
      // 屏幕常亮
      screenWakeLock: {
        android: true,
        ios: true,
        note: "两个平台都支持，使用 wakelock_plus，仅在计时页面启用",
      },
      
      // 状态恢复
      stateRecovery: {
        android: true,
        ios: true,
        note: "两个平台都支持，基于时间戳回算，不依赖后台运行",
      },
    },
    
    // 用户体验差异总结
    userExperienceDifferences: {
      // 场景 1：开始计时后切到后台
      scenario1_background: {
        android: {
          experience: "下拉通知栏可看到倒计时实时更新，可直接操作暂停/结束",
          visual: "通知栏显示：🍅 专注中 | 剩余 23:45 | [暂停] [结束]",
        },
        ios: {
          experience: "无法在通知栏看到倒计时（除非实现 Live Activities）",
          visual: "通知栏无显示，锁屏/动态岛可能显示（Live Activities）",
        },
      },
      
      // 场景 2：锁屏时查看
      scenario2_lockscreen: {
        android: {
          experience: "通知栏可见（取决于系统设置），可直接操作",
          visual: "锁屏通知栏显示倒计时和操作按钮",
        },
        ios: {
          experience: "Live Activities 显示实时倒计时（iOS 16+），否则仅到点通知",
          visual: "锁屏显示 Live Activity 卡片或到点通知",
        },
      },
      
      // 场景 3：到点提醒
      scenario3_completion: {
        android: {
          experience: "通知栏显示'已完成'，响铃/震动提醒",
          visual: "通知：🍅 专注完成 | 时间到了，休息一下吧",
        },
        ios: {
          experience: "本地通知提醒，点击跳回应用",
          visual: "通知横幅/锁屏显示：🍅 专注完成 | 时间到了，休息一下吧",
        },
      },
      
      // 场景 4：App 被关闭后重新打开
      scenario4_recovery: {
        android: {
          experience: "自动恢复计时状态，显示准确的剩余时间",
          note: "基于持久化的时间戳回算",
        },
        ios: {
          experience: "自动恢复计时状态，显示准确的剩余时间",
          note: "基于持久化的时间戳回算",
        },
      },
    },
  },

  // ===========================================
  // 3. Android 前台服务通知设计
  // ===========================================
  androidForegroundService: {
    // 通知栏设计
    notificationDesign: {
      // 通知渠道
      channel: {
        id: "grano_timer",
        name: "GranoFlow Timer",
        description: "番茄计时进行中",
        importance: "HIGH",
        priority: "HIGH",
        note: "使用 NotificationChannelImportance.HIGH 确保通知可见",
      },
      
      // 通知内容
      content: {
        // 标题
        title: "专注中",
        // 正文（实时更新）
        text: "剩余 MM:SS",
        // 小图标
        smallIcon: {
          type: "mipmap",
          name: "ic_launcher",
          note: "放在 android/app/src/main/res/mipmap/ 或 drawable/",
        },
        // 大图标（可选）
        largeIcon: null,
        // 常驻通知
        isSticky: true,
        // 可见性
        visibility: "VISIBILITY_PUBLIC",
      },
      
      // 操作按钮
      actions: [
        {
          id: "pause",
          label: "暂停",
          icon: "Icons.pause",
          note: "点击后暂停计时并停止前台服务",
        },
        {
          id: "stop",
          label: "结束",
          icon: "Icons.stop",
          note: "点击后结束计时并停止前台服务",
        },
      ],
      
      // 点击通知行为
      tapAction: {
        behavior: "打开应用并跳转到计时页面",
        note: "如果计时仍在进行，自动恢复状态",
      },
    },
    
    // 前台服务配置
    serviceConfig: {
      // 服务类型
      foregroundServiceType: [
        "dataSync",
        "shortService",
        "note": "根据 Android 14+ 要求，至少需要一种服务类型",
      ],
      
      // 更新频率
      updateInterval: 1000, // 毫秒，每秒更新一次
      
      // 唤醒锁
      allowWakeLock: true,
      allowWifiLock: true,
      
      // 启动时机
      startTrigger: "用户点击'开始'按钮时",
      stopTrigger: [
        "用户点击'暂停'按钮",
        "用户点击'结束'按钮",
        "倒计时到点自动完成",
        "用户点击通知栏的'暂停'/'结束'按钮",
      ],
    },
    
    // 权限要求
    permissions: {
      required: [
        {
          permission: "POST_NOTIFICATIONS",
          minSdk: 33, // Android 13+
          note: "Android 13+ 需要运行时请求通知权限",
        },
        {
          permission: "FOREGROUND_SERVICE",
          minSdk: 28, // Android 9+
          note: "Android 9+ 需要前台服务权限",
        },
      ],
      optional: [
        {
          permission: "REQUEST_IGNORE_BATTERY_OPTIMIZATIONS",
          note: "引导用户加入电池优化白名单，避免被系统杀死",
          userGuidance: "可调用 FlutterForegroundTask.openIgnoreBatteryOptimizationSettings()",
        },
      ],
    },
  },

  // ===========================================
  // 4. iOS 通知设计
  // ===========================================
  iosNotifications: {
    // 本地通知
    localNotification: {
      // 通知内容
      content: {
        title: "专注完成",
        body: "时间到了，休息一下吧",
        sound: "default", // 或自定义音频文件
        badge: 1, // 可选：应用角标数字
      },
      
      // 调度时机
      schedule: {
        trigger: "倒计时到点时",
        method: "使用 flutter_local_notifications 的 zonedSchedule",
        timezone: "使用 timezone 包处理时区",
      },
      
      // 点击通知行为
      tapAction: {
        behavior: "打开应用并跳转到计时页面",
        note: "如果计时已完成，显示完成状态",
      },
    },
    
    // Live Activities（可选，iOS 16+）
    liveActivities: {
      // 功能说明
      description: "在锁屏和动态岛显示实时更新的倒计时",
      
      // 显示位置
      displayLocations: [
        "锁屏屏幕",
        "动态岛（iPhone 14 Pro+）",
        "通知中心（部分情况下）",
      ],
      
      // 显示内容
      content: {
        title: "专注中",
        countdown: "剩余 MM:SS",
        note: "实时更新，无需后台运行，由系统自动刷新",
      },
      
      // 实现要求
      implementation: {
        requirement: "需要创建 ActivityKit 扩展（原生 Swift 代码）",
        flutterIntegration: "使用平台通道或第三方插件（如 live_activities）",
        note: "这是可选功能，基础方案可以不实现",
      },
      
      // 生命周期
      lifecycle: {
        start: "用户点击'开始'按钮时启动 Live Activity",
        update: "暂停/继续时更新 Live Activity 状态",
        end: "完成或结束时结束 Live Activity",
      },
    },
    
    // 权限要求
    permissions: {
      required: [
        {
          permission: "通知权限",
          requestMethod: "使用 UNUserNotificationCenter.requestAuthorization",
          note: "首次使用时会弹出系统权限请求",
        },
      ],
      optional: [
        {
          permission: "Live Activities 权限",
          requirement: "iOS 16+",
          note: "Live Activities 不需要额外权限，但需要用户允许通知",
        },
      ],
    },
  },

  // ===========================================
  // 5. 屏幕常亮功能
  // ===========================================
  screenWakeLock: {
    // 功能说明
    description: "在计时页面保持屏幕常亮，避免熄屏打断专注",
    
    // 平台支持
    platformSupport: {
      android: true,
      ios: true,
      note: "使用 wakelock_plus 包，跨平台支持",
    },
    
    // 启用时机
    enableTrigger: "进入计时页面（PomodoroPage）时",
    
    // 禁用时机
    disableTrigger: [
      "离开计时页面时",
      "计时完成时",
      "用户手动暂停时（可选，根据需求决定）",
    ],
    
    // 实现细节
    implementation: {
      package: "wakelock_plus",
      methods: {
        enable: "WakelockPlus.enable()",
        disable: "WakelockPlus.disable()",
      },
      note: "需要在页面生命周期中正确管理，避免内存泄漏",
    },
  },

  // ===========================================
  // 6. 生命周期恢复机制
  // ===========================================
  lifecycleRecovery: {
    // 恢复策略
    strategy: "基于时间戳回算，不依赖后台运行的计时器",
    
    // 恢复时机
    recoveryTriggers: [
      "App 从后台切回前台（AppLifecycleState.resumed）",
      "计时页面重新可见时",
      "App 被系统关闭后重新打开时",
    ],
    
    // 恢复流程
    recoveryFlow: [
      "1. 读取持久化的计时状态（isStarted, isPaused, startTime, pausePeriods 等）",
      "2. 使用 actualRunningTime 计算当前实际运行时间",
      "3. 计算剩余时间 = countdownDuration - actualRunningTime",
      "4. 更新 UI 显示",
      "5. 如果计时仍在进行且当前路由不是计时页，自动跳转到计时页（可选）",
    ],
    
    // 状态持久化
    persistence: {
      storage: "使用 SharedPreferences 或 Isar 数据库",
      data: {
        isStarted: "boolean",
        isPaused: "boolean",
        startTime: "DateTime (时间戳)",
        pausePeriods: "List<({start: DateTime, end: DateTime})>",
        countdownDuration: "int (秒)",
        originalCountdownDuration: "int (秒)",
        focusSessionId: "int?",
      },
      updateFrequency: "每次状态变化时立即保存",
    },
    
    // 边界情况处理
    edgeCases: {
      // App 被系统杀死
      appKilled: {
        scenario: "用户强制关闭 App 或系统回收内存",
        handling: "重新打开 App 时从持久化状态恢复，基于时间戳回算剩余时间",
      },
      
      // 系统时间被修改
      systemTimeChanged: {
        scenario: "用户在计时过程中修改了系统时间",
        handling: "检测到时间异常时，使用最后一次保存的时间戳，避免负数或异常值",
        note: "这是一个极端情况，可以记录警告日志",
      },
      
      // 跨时区
      timezoneChange: {
        scenario: "用户在计时过程中跨时区（如飞行）",
        handling: "使用 UTC 时间戳存储，显示时转换为本地时间",
      },
    },
  },

  // ===========================================
  // 7. 交互流程
  // ===========================================
  interactions: {
    // 用户操作流程
    userFlows: [
      {
        name: "开始计时流程",
        steps: [
          "用户点击'开始'按钮",
          "保存开始时间戳到持久化存储",
          "Android: 启动前台服务，显示通知栏倒计时",
          "iOS: 调度本地通知（到点提醒），可选启动 Live Activity",
          "启用屏幕常亮",
          "开始播放滴答声（如果开启）",
          "UI 开始显示倒计时",
        ],
      },
      
      {
        name: "切到后台流程",
        steps: [
          "用户切到后台或锁屏",
          "Android: 前台服务继续运行，通知栏显示倒计时",
          "iOS: 应用被挂起，Live Activity（如果实现）继续显示",
          "屏幕常亮保持（如果仍在计时页面）",
        ],
      },
      
      {
        name: "切回前台流程",
        steps: [
          "用户切回应用",
          "检测到 AppLifecycleState.resumed",
          "从持久化存储读取状态",
          "基于时间戳回算剩余时间",
          "更新 UI 显示",
          "如果计时仍在进行且不在计时页，可选自动跳转",
        ],
      },
      
      {
        name: "暂停流程",
        steps: [
          "用户点击'暂停'按钮（页面内或通知栏）",
          "记录暂停开始时间",
          "Android: 停止前台服务，更新通知为'已暂停'",
          "iOS: 更新 Live Activity 状态为'已暂停'（如果实现）",
          "禁用屏幕常亮",
          "停止播放滴答声",
          "保存状态到持久化存储",
        ],
      },
      
      {
        name: "继续流程",
        steps: [
          "用户点击'继续'按钮",
          "记录暂停结束时间，计算暂停时长",
          "Android: 重新启动前台服务，恢复通知栏倒计时",
          "iOS: 更新 Live Activity 状态为'进行中'（如果实现）",
          "启用屏幕常亮",
          "恢复播放滴答声",
          "保存状态到持久化存储",
        ],
      },
      
      {
        name: "到点完成流程",
        steps: [
          "倒计时归零",
          "Android: 前台服务检测到到点，更新通知为'已完成'，停止服务",
          "iOS: 本地通知触发，显示'专注完成'提醒",
          "播放完成音效",
          "禁用屏幕常亮",
          "保存完成状态到持久化存储",
          "用户点击通知或打开应用，显示完成状态",
        ],
      },
    ],
    
    // 通知交互
    notificationInteractions: {
      android: {
        tapNotification: "打开应用并跳转到计时页面，恢复状态",
        tapPause: "暂停计时，停止前台服务，更新通知",
        tapStop: "结束计时，停止前台服务，清除通知",
      },
      ios: {
        tapNotification: "打开应用并跳转到计时页面，显示完成状态",
        tapLiveActivity: "打开应用并跳转到计时页面（如果实现）",
      },
    },
  },

  // ===========================================
  // 8. 技术实现架构
  // ===========================================
  technicalArchitecture: {
    // 服务层设计
    serviceLayer: {
      // 统一接口
      abstractService: {
        name: "TimerBackgroundService",
        location: "lib/core/services/timer_background_service.dart",
        methods: [
          "startTimer({required DateTime endTime, required Duration duration})",
          "pauseTimer()",
          "resumeTimer()",
          "stopTimer()",
        ],
      },
      
      // Android 实现
      androidImplementation: {
        name: "AndroidForegroundTimerService",
        location: "lib/core/services/android_foreground_timer_service.dart",
        dependencies: ["flutter_foreground_task"],
        note: "仅在 Android 平台编译/运行",
      },
      
      // iOS 实现
      iosImplementation: {
        name: "IOSNotificationTimerService",
        location: "lib/core/services/ios_notification_timer_service.dart",
        dependencies: ["flutter_local_notifications", "timezone"],
        note: "仅在 iOS 平台编译/运行",
      },
      
      // 平台工厂
      platformFactory: {
        name: "createTimerBackgroundService()",
        location: "lib/core/services/timer_background_service_impl.dart",
        method: "使用条件导入（conditional imports）或 Platform.isAndroid/iOS 判断",
      },
    },
    
    // 依赖包
    dependencies: {
      required: [
        {
          package: "flutter_local_notifications",
          version: "^17.2.0",
          platforms: ["android", "ios"],
          purpose: "跨平台通知功能",
        },
        {
          package: "wakelock_plus",
          version: "^1.2.0",
          platforms: ["android", "ios"],
          purpose: "屏幕常亮功能",
        },
        {
          package: "timezone",
          version: "^0.9.2",
          platforms: ["ios"],
          purpose: "iOS 通知时区处理",
        },
      ],
      androidOnly: [
        {
          package: "flutter_foreground_task",
          version: "^8.10.0",
          platforms: ["android"],
          purpose: "Android 前台服务",
          note: "iOS 上不会报错，但调用会失败，需要用平台检测保护",
        },
      ],
    },
    
    // 状态管理集成
    stateManagement: {
      integration: "与现有的 PomodoroTimerNotifier 集成",
      modifications: [
        "start() 方法：调用 TimerBackgroundService.startTimer()",
        "pause() 方法：调用 TimerBackgroundService.pauseTimer()",
        "resume() 方法：调用 TimerBackgroundService.resumeTimer()",
        "reset() 方法：调用 TimerBackgroundService.stopTimer()",
      ],
    },
  },

  // ===========================================
  // 9. 待确认问题
  // ===========================================
  openQuestions: [
    {
      question: "是否实现 iOS Live Activities？",
      description: "Live Activities 可以在锁屏/动态岛显示实时倒计时，提供更好的 iOS 用户体验，但需要额外的原生代码实现",
      options: [
        "方案 A：不实现 Live Activities，仅使用本地通知（到点提醒）",
        "方案 B：实现 Live Activities，提供与 Android 接近的体验",
      ],
      recommendation: "建议先实现方案 A（基础功能），Live Activities 作为后续优化",
      confirmed: false,
    },
    
    {
      question: "暂停时是否禁用屏幕常亮？",
      description: "用户暂停计时时，是否应该允许屏幕自动熄屏？",
      options: [
        "方案 A：暂停时禁用屏幕常亮，允许熄屏",
        "方案 B：暂停时保持屏幕常亮，直到用户离开页面或结束计时",
      ],
      recommendation: "方案 A：暂停时禁用屏幕常亮，节省电量",
      confirmed: false,
    },
    
    {
      question: "切回前台时是否自动跳转到计时页？",
      description: "如果用户切到后台后，计时仍在进行，切回前台时是否应该自动跳转到计时页面？",
      options: [
        "方案 A：自动跳转，确保用户看到计时状态",
        "方案 B：不自动跳转，用户手动导航",
      ],
      recommendation: "方案 A：自动跳转，提供'计时优先'的体验",
      confirmed: false,
    },
    
    {
      question: "Android 通知栏操作按钮的具体行为？",
      description: "通知栏的'暂停'和'结束'按钮点击后，是否应该立即停止前台服务？",
      options: [
        "方案 A：立即停止前台服务，清除通知",
        "方案 B：保持通知显示，但更新为'已暂停'/'已结束'状态",
      ],
      recommendation: "方案 A：立即停止前台服务，符合用户预期",
      confirmed: false,
    },
    
    {
      question: "状态持久化的存储方案？",
      description: "使用 SharedPreferences 还是 Isar 数据库存储计时状态？",
      options: [
        "方案 A：使用 SharedPreferences（简单快速）",
        "方案 B：使用 Isar 数据库（与现有数据层一致）",
      ],
      recommendation: "方案 B：使用 Isar 数据库，保持架构一致性",
      confirmed: false,
    },
  ],
}
