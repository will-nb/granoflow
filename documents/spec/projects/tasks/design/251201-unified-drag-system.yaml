meta:
  id: "251201-unified-drag-system"
  title: "统一拖拽系统：同时支持列表排序和任务移入"
  status: draft
  owner: "AI Assistant"
  created_at: "2025-11-01"
  version: "1.0"

background:
  problem: |
    当前拖拽系统存在手势冲突问题：
    
    1. **排序功能**（使用 ReorderableListView）：
       - 通过 `ReorderableDragStartListener` 启动拖拽
       - 传递索引数据（int），用于列表内重排序
       - 显示相邻任务让位动画（yielding animation）
       - 触发区域：整个任务卡片
    
    2. **移入功能**（使用 DragTarget）：
       - 通过 `StandardDraggable` 的 `LongPressDraggable<Task>` 启动拖拽
       - 传递 Task 数据，用于将任务设为子任务
       - 显示目标任务变色（hover 效果）
       - 触发区域：整个任务卡片
    
    3. **冲突根源**：
       - `ReorderableDragStartListener` 包裹整个 item，优先捕获长按手势
       - 一旦被捕获，启动 ReorderableListView 的内部拖拽系统（传递索引）
       - `StandardDraggable` 的 `LongPressDraggable<Task>` 无法启动
       - `DragTarget<Task>` 收不到 Task 数据，只能收到索引数据
       - 结果：排序功能正常，移入功能失效
    
    4. **当前状态**：
       - Inbox 和 Tasks 页面的排序功能正常工作
       - 拖拽移入功能完全失效（目标任务不变色，松手后回到原地）

  goal: |
    实现统一拖拽系统，在一个长按拖拽中同时支持：
    1. **列表内排序**：在两个任务之间显示插入位置，相邻任务让位
    2. **任务移入**：在目标任务上显示变色高亮，使其成为子任务
    3. **智能判断**：根据拖拽位置自动判断用户意图（排序 vs 移入）
    4. **统一视觉反馈**：同时显示两种动画，让用户清楚看到两种可能
    5. **最终决策**：松手时根据当前位置决定执行排序还是移入操作

design_principles:
  - |
    一个手势，两种可能，智能判断
  - |
    在拖拽过程中同时显示两种视觉反馈，让用户清楚看到所有可能的结果
  - |
    根据拖拽位置自动判断用户意图，松手时执行对应操作
  - |
    容错区间足够大，确保用户可以轻松操作

user_flows:
  - name: "统一拖拽：排序场景"
    steps:
      - "用户在 Inbox 或 Tasks 页面长按任务 A 开始拖拽"
      - "将任务 A 拖到两个任务之间（B 和 C 之间）"
      - "系统显示：插入线（在 B 和 C 之间）+ 相邻任务让位动画"
      - "任务 B 和 C 变色高亮（显示可以作为移入目标）"
      - "用户继续移动，插入线跟随鼠标位置"
      - "用户在插入线上方或下方约 16 像素容错区间内松手"
      - "系统判定为排序操作，调用 `onReorder` 更新 `sortIndex`"
      - "任务 A 移动到新位置，相邻任务恢复原位置"

  - name: "统一拖拽：移入场景"
    steps:
      - "用户在 Inbox 或 Tasks 页面长按任务 A 开始拖拽"
      - "将任务 A 拖到任务 B 的中间区域（排除上下边缘 16 像素）"
      - "系统显示：任务 B 变色高亮（hover 效果）+ 相邻任务让位动画"
      - "如果任务 B 在任务 A 的相邻位置，相邻任务仍然让位（即使不移入）"
      - "用户继续移动，hover 效果跟随鼠标位置"
      - "用户在任务 B 的中间区域松手"
      - "系统判定为移入操作，调用 `handleDropOnTask` 更新 `parentId`"
      - "任务 A 成为任务 B 的子任务，列表刷新显示层级关系"

  - name: "统一拖拽：边界情况"
    steps:
      - "用户在任务 B 的上边缘 16 像素内松手"
      - "系统判定为排序操作（在任务 B 之前插入）"
      - "用户在任务 B 的下边缘 16 像素内松手"
      - "系统判定为排序操作（在任务 B 之后插入）"
      - "用户在任务 B 的中间区域松手"
      - "系统判定为移入操作（使任务 A 成为任务 B 的子任务）"

technical_design:
  architecture:
    overview: |
      移除 `ReorderableDragStartListener`，完全使用 `StandardDraggable` 的 `LongPressDraggable<Task>` 启动拖拽。
      在拖拽过程中，根据鼠标位置动态判断用户意图：
      - 在两个任务之间（插入容错区间内）→ 显示排序动画
      - 在任务中间区域 → 显示移入动画
      松手时根据当前位置执行对应操作。
    
    component_structure: |
      ReorderableListView.builder (移除 onReorder，改用自定义拖拽)
        - TaskDragIntentTarget.surface (DragTarget，接收 Task 数据)
          - TaskDragIntentTarget.insertion (插入目标，上下各 16 像素)
          - InboxTaskTile / TaskWithParentChain
            - TaskTileContent
              - StandardDraggable<Task> (LongPressDraggable，启动拖拽)
                - TaskRowContent

    key_components:
      - name: "StandardDraggable<Task>"
        role: "启动统一拖拽，传递 Task 数据"
        notes: |
          - 使用 `LongPressDraggable<Task>` 启动拖拽
          - 传递完整的 Task 对象
          - 提供统一的视觉反馈（proxyDecorator）
      
      - name: "TaskDragIntentTarget.surface"
        role: "接收拖拽 Task，实现移入功能"
        notes: |
          - `DragTarget<Task>` 包裹整个任务卡片
          - 在鼠标悬停时显示 hover 效果（变色高亮）
          - 松手时如果判定为移入，调用 `handleDropOnTask`
      
      - name: "TaskDragIntentTarget.insertion"
        role: "显示插入位置，实现排序功能"
        notes: |
          - `DragTarget<Task>` 放置在两个任务之间
          - 容错区间：上下各 16 像素（包括 12 像素 margin + 4 像素额外命中区）
          - 在鼠标悬停时显示插入线（2 像素高亮线）
          - 松手时如果判定为排序，调用 `handleReorder`

  position_detection:
    algorithm: |
      在拖拽过程中，持续跟踪鼠标位置（通过 DragTarget 的 onMove 回调）：
      
      1. **获取鼠标位置**：
         - 使用 `DragTarget.onMove` 回调获取 `DragTargetDetails.localPosition`
         - 转换为相对于任务列表的全局坐标
      
      2. **判断插入位置**：
         - 遍历所有插入目标（TaskDragIntentTarget.insertion）
         - 检查鼠标是否在插入目标的命中区域内
         - 命中区域 = 插入线高度（2 像素） + 上下容错区间（各 16 像素）= 总高度 34 像素
      
      3. **判断任务表面**：
         - 遍历所有任务表面（TaskDragIntentTarget.surface）
         - 检查鼠标是否在任务卡片的中间区域
         - 中间区域 = 任务卡片总高度 - 上下边缘各 16 像素
      
      4. **优先级规则**：
         - 如果同时命中插入目标和任务表面，优先判定为插入（排序）
         - 这样确保用户在任务边缘更容易触发排序

  visual_feedback:
    sorting_feedback:
      - |
        **移动让位动画**（唯一视觉反馈）：
        - 效果：相邻任务平滑移动，为插入位置腾出空间
        - 实现：使用 AnimatedList 或手动计算位置偏移
        - 动画：300ms 缓动曲线（easeOutCubic）
        - 容错区间：插入目标区域总高度 34 像素（基础 2 像素 + 上下各 16 像素容错）
        - 注意：不渲染插入线，视觉反馈完全依靠移动让位动画
    
    drag_in_feedback:
      - |
        **任务变色高亮**：
        - 位置：整个任务卡片
        - 外观：半透明主题色背景（alpha: 0.3），圆角 8 像素
        - 显示时机：鼠标在任务中间区域时
        - 动画：淡入淡出，180ms 过渡
      
      - |
        **相邻任务让位**：
        - 效果：即使移入，相邻任务仍然让位（如果拖拽的任务需要插入新位置）
        - 实现：与排序反馈共享动画系统
        - 视觉上让用户清楚看到两种可能

  tolerance_zones:
    insertion_zone: |
      **插入容错区间**：
      - 总高度：34 像素（2 像素插入线 + 上下各 16 像素容错）
      - 上容错区间：16 像素（任务 B 上边缘上方 12 像素 margin + 4 像素额外命中）
      - 下容错区间：16 像素（任务 B 下边缘下方 12 像素 margin + 4 像素额外命中）
      - 插入线：2 像素，位于容错区间中间
      - 视觉表现：只有插入线可见（2 像素），容错区间透明但可命中
      - 目的：确保用户可以轻松在两个任务之间插入
    
    task_surface_zone: |
      **任务表面容错区间**：
      - 中间区域：任务卡片总高度 - 上下边缘各 16 像素
      - 上边缘排除区：16 像素（判定为插入到任务之前）
      - 下边缘排除区：16 像素（判定为插入到任务之后）
      - 视觉表现：整个任务卡片都是 DragTarget，但只有中间区域判定为移入
      - 目的：在任务边缘更容易触发排序，在中间区域更容易触发移入

implementation_plan:
  phase_1_core_system:
    name: "核心拖拽系统重构"
    tasks:
      - "移除 `ReorderableDragStartListener`，改用 `StandardDraggable` 启动拖拽"
      - "移除 `ReorderableListView.onReorder`，改用自定义排序处理"
      - "实现位置检测逻辑：判断鼠标是在插入区间还是任务表面"
      - "实现视觉反馈系统：同时显示插入线和任务变色"
      - "实现相邻任务让位动画（使用 AnimatedList 或手动偏移）"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
      - "lib/presentation/tasks/views/task_section_list.dart"
      - "lib/presentation/common/drag/task_drag_intent_target.dart"
      - "lib/presentation/common/drag/standard_drag_target.dart"
      - "lib/core/constants/drag_constants.dart"
    
    estimated_effort: "3-4 hours"

  phase_2_insertion_targets:
    name: "插入目标实现"
    tasks:
      - "在 `InboxTaskList` 中实现插入目标（两个任务之间）"
      - "在 `TaskSectionTaskModeList` 中实现插入目标"
      - "设置容错区间：上下各 16 像素"
      - "实现插入线视觉反馈（2 像素高亮线）"
      - "实现插入位置检测逻辑"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
      - "lib/presentation/tasks/views/task_section_list.dart"
      - "lib/presentation/common/drag/task_drag_intent_target.dart"
      - "lib/core/constants/drag_constants.dart"
    
    estimated_effort: "2-3 hours"

  phase_3_position_detection:
    name: "位置检测与决策逻辑"
    tasks:
      - "实现全局坐标转换逻辑"
      - "实现插入位置检测（检查鼠标是否在插入容错区间内）"
      - "实现任务表面检测（检查鼠标是否在任务中间区域）"
      - "实现优先级判断（插入优先于移入）"
      - "实现松手时的最终决策逻辑（排序 vs 移入）"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
      - "lib/presentation/tasks/views/task_section_list.dart"
      - "lib/presentation/widgets/task_drag_intent_helper.dart"
    
    estimated_effort: "2-3 hours"

  phase_4_visual_feedback:
    name: "视觉反馈优化"
    tasks:
      - "实现相邻任务让位动画（平滑移动）"
      - "优化插入线动画（淡入淡出）"
      - "优化任务变色动画（hover 效果）"
      - "确保两种动画可以同时显示且不冲突"
      - "测试各种边界情况下的视觉效果"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
      - "lib/presentation/tasks/views/task_section_list.dart"
      - "lib/presentation/widgets/reorderable_proxy_decorator.dart"
    
    estimated_effort: "2-3 hours"

  phase_5_testing:
    name: "测试与优化"
    tasks:
      - "单元测试：位置检测逻辑"
      - "单元测试：决策逻辑（排序 vs 移入）"
      - "集成测试：完整拖拽流程"
      - "性能测试：动画流畅度"
      - "用户体验测试：容错区间是否足够"
      - "边界情况测试：快速拖拽、边界拖拽等"
    
    files_to_modify:
      - "test/integration/tasks/unified_drag_test.dart (新建)"
      - "test/unit/widgets/task_drag_position_detector_test.dart (新建)"
    
    estimated_effort: "2-3 hours"

constants:
  insertion_tolerance: |
    ```dart
    // lib/core/constants/drag_constants.dart
    class DragConstants {
      // 插入线高度（可见）
      static const double insertionLineHeight = 2.0;
      
      // 插入容错区间（上下各 16 像素）
      static const double insertionToleranceZone = 16.0;
      
      // 插入目标总高度（容错区间 + 插入线）
      static const double insertionTargetHeight = 
          insertionLineHeight + (insertionToleranceZone * 2); // 34 像素
      
      // 任务表面排除区（上下各 16 像素，判定为插入）
      static const double taskSurfaceExclusionZone = 16.0;
      
      // 插入线 margin（视觉间距）
      static const double insertionLineMargin = 12.0;
    }
    ```

risks:
  - |
    **性能风险**：
    - 实时位置检测可能影响性能（特别是任务列表很长时）
    - 缓解：使用节流（throttle）限制检测频率，或使用 RenderBox 的高效坐标转换
    
  - |
    **用户体验风险**：
    - 容错区间可能仍然太小或太大
    - 缓解：先实现 16 像素，根据用户反馈调整
    
  - |
    **动画冲突**：
    - 同时显示插入线和任务变色可能导致视觉混乱
    - 缓解：插入线和任务变色使用不同颜色，或根据优先级隐藏其中一个
    
  - |
    **坐标转换复杂性**：
    - 需要准确转换全局坐标到相对坐标
    - 缓解：使用 Flutter 提供的 RenderBox.localToGlobal 和 globalToLocal 方法

alternatives:
  - |
    **方案 A：保持当前结构，只修复手势冲突**
    - 优点：改动最小
    - 缺点：仍然存在两个独立的拖拽系统，用户体验不一致
    - 状态：已尝试，但手势冲突难以完全解决
  
  - |
    **方案 B：分离拖拽手柄（从图标拖拽移入，从卡片拖拽排序）**
    - 优点：交互明确，不会混淆
    - 缺点：用户需要学习两种不同的拖拽方式，增加学习成本
    - 状态：未尝试，可能作为备选方案

success_criteria:
  - |
    **功能完整性**：
    - ✅ 列表内排序功能正常工作
    - ✅ 拖拽移入功能正常工作
    - ✅ 两种功能在同一个拖拽手势中可用
    - ✅ 根据拖拽位置自动判断用户意图
  
  - |
    **用户体验**：
    - ✅ 容错区间足够大，用户可以轻松操作
    - ✅ 视觉反馈清晰，用户可以清楚看到两种可能
    - ✅ 动画流畅，无卡顿或延迟
    - ✅ 边界情况处理得当（快速拖拽、边界拖拽等）
  
  - |
    **代码质量**：
    - ✅ 代码结构清晰，易于维护
    - ✅ 性能良好，不影响列表滚动和渲染
    - ✅ 测试覆盖完整，包括单元测试和集成测试

