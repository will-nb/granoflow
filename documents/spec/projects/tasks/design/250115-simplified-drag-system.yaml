meta:
  id: "250115-simplified-drag-system"
  title: "简化拖拽系统：基于 level 的层级拖拽逻辑"
  status: draft
  owner: "AI Assistant"
  created_at: "2025-01-15"
  version: "1.0"

background:
  problem: |
    当前拖拽系统存在以下问题：
    
    1. **让位动画问题**：
       - 当拖拽经过多个任务时，每个让位都会留下空白间隔
       - 任务没有连续排列，视觉上出现多余的空隙
       - 原因是每个任务独立计算 transform，没有全局协调
    
    2. **拖拽逻辑复杂**：
       - 需要判断水平拖拽方向（左右移动超过 30px）
       - 需要处理不同层级的任务（根任务、子任务）
       - 需要判断 beforeTask 和 afterTask 是否是兄弟
       - 需要根据深度比较决定 parentId
       - 逻辑过于复杂，容易出错
    
    3. **层级判断不清晰**：
       - 没有统一的 level 概念（1/2/3）
       - 每次计算深度都需要传递 taskMap
       - 难以判断任务是否可以拖拽

  goal: |
    通过引入 level 概念和简化拖拽规则，实现：
    1. **清晰的层级系统**：level 1/2/3 对应根任务/二级任务/三级任务
    2. **简化的拖拽逻辑**：
       - 根任务（level 1）：拖拽时自动收缩子任务，只处理同级排序
       - 子任务（level 2/3）：只能在父任务的扩展区域内拖拽
       - 移出扩展区自动提升为根任务
    3. **正确的让位动画**：只在同级任务之间让位，避免空白间隔
    4. **统一的 sortIndex 计算**：创建专门的类处理，避免硬编码

design_principles:
  - |
    简化优于复杂：通过限制拖拽范围，减少判断逻辑
  - |
    明确的层级概念：level 1/2/3 清晰区分任务层级
  - |
    用户友好的自动处理：移出扩展区自动提升，用户以为是手抖
  - |
    代码可维护：统一的 sortIndex 计算类，避免硬编码

user_flows:
  - name: "拖拽根任务（level 1）"
    steps:
      - "用户在 Inbox 页面长按根任务 A 开始拖拽"
      - "系统自动收缩任务 A 的所有子任务（从 expandedTaskIds 中移除）"
      - "拖拽过程中只显示根任务，子任务已隐藏"
      - "用户将任务 A 拖到两个根任务之间"
      - "系统显示让位动画，只有根任务参与让位"
      - "用户松手，任务 A 移动到新位置，更新 sortIndex"

  - name: "拖拽子任务（level 2/3）- 扩展区内"
    steps:
      - "用户展开任务 A（根任务），显示其子任务 B、C、D"
      - "用户长按子任务 B 开始拖拽"
      - "系统检查：任务 B 已展开，允许拖拽"
      - "系统自动收缩任务 B 的所有子任务（如果有）"
      - "用户将任务 B 拖到子任务 C 上"
      - "系统检测：仍在扩展区内（父任务 A 的子任务区域）"
      - "系统显示让位动画，只有子任务 B、C、D 参与让位"
      - "用户松手，任务 B 成为任务 C 的子任务"

  - name: "拖拽子任务（level 2/3）- 移出扩展区"
    steps:
      - "用户展开任务 A（根任务），显示其子任务 B、C、D"
      - "用户长按子任务 B 开始拖拽"
      - "用户将任务 B 拖出父任务 A 的扩展区域（拖到其他根任务附近）"
      - "系统检测：已移出扩展区"
      - "系统自动提升任务 B 为根任务（level 1），修改 sortIndex"
      - "系统结束拖拽"
      - "用户以为是手抖了，会再次执行拖拽"

  - name: "拖拽子任务到插入间隔"
    steps:
      - "用户展开任务 A（根任务），显示其子任务 B、C、D"
      - "用户长按子任务 B 开始拖拽"
      - "用户将任务 B 拖到子任务 C 和 D 之间的插入间隔"
      - "系统检测：仍在扩展区内"
      - "系统显示让位动画，子任务 C、D 向上让位"
      - "用户松手，任务 B 成为任务 C 的兄弟（使用 beforeTask.parentId）"

technical_design:
  level_system:
    overview: |
      引入 level 概念，明确区分任务层级：
      - level 1: 根任务（parentId 是 null/里程碑/project）
      - level 2: 二级任务（parentId 指向 level 1 的任务）
      - level 3: 三级任务（parentId 指向 level 2 的任务）
    
    implementation: |
      在 `lib/presentation/tasks/utils/hierarchy_utils.dart` 中添加：
      
      ```dart
      /// 计算任务的层级（level 1/2/3）
      /// level 1: 根任务（parentId 是 null/里程碑/project）
      /// level 2: 二级任务
      /// level 3: 三级任务
      /// 
      /// [task] 要计算层级的任务
      /// [taskMap] 任务 ID 到任务的映射（用于查找父任务）
      /// 返回任务的层级（1-3）
      int getTaskLevel(Task task, Map<int, Task> taskMap) {
        return calculateTaskDepthSync(task, taskMap) + 1;
      }
      ```
      
      注意：项目和里程碑不计入层级深度，所以需要正确计算。

  sort_index_calculator:
    overview: |
      创建专门的类来处理 sortIndex 计算，避免硬编码。
      提供统一的 API 来计算排序索引，支持：
      - 插入到最前面
      - 插入到最后面
      - 插入到两个任务之间
      - 插入到任务之后
    
    implementation: |
      创建新文件 `lib/presentation/tasks/utils/sort_index_calculator.dart`：
      
      ```dart
      /// 排序索引计算器
      /// 
      /// 提供统一的 sortIndex 计算逻辑，避免硬编码
      class SortIndexCalculator {
        /// 默认的排序间隔（用于插入操作）
        static const double defaultInterval = 1000.0;
        
        /// 插入到最前面
        /// 
        /// [firstTask] 第一个任务的 sortIndex（如果列表为空则为 null）
        /// 返回新的 sortIndex
        static double insertAtFirst(double? firstTaskSortIndex) {
          if (firstTaskSortIndex == null) {
            return TaskConstants.DEFAULT_SORT_INDEX;
          }
          return firstTaskSortIndex - defaultInterval;
        }
        
        /// 插入到最后面
        /// 
        /// [lastTask] 最后一个任务的 sortIndex（如果列表为空则为 null）
        /// 返回新的 sortIndex
        static double insertAtLast(double? lastTaskSortIndex) {
          if (lastTaskSortIndex == null) {
            return TaskConstants.DEFAULT_SORT_INDEX;
          }
          return lastTaskSortIndex + defaultInterval;
        }
        
        /// 插入到两个任务之间
        /// 
        /// [beforeTask] 前面任务的 sortIndex
        /// [afterTask] 后面任务的 sortIndex
        /// 返回新的 sortIndex
        static double insertBetween(double beforeTaskSortIndex, double afterTaskSortIndex) {
          return (beforeTaskSortIndex + afterTaskSortIndex) / 2;
        }
        
        /// 插入到任务之后
        /// 
        /// [task] 任务的 sortIndex
        /// 返回新的 sortIndex
        static double insertAfter(double taskSortIndex) {
          return taskSortIndex + defaultInterval;
        }
        
        /// 插入到任务之前
        /// 
        /// [task] 任务的 sortIndex
        /// 返回新的 sortIndex
        static double insertBefore(double taskSortIndex) {
          return taskSortIndex - defaultInterval;
        }
      }
      ```

  drag_start_logic:
    root_task_level_1:
      overview: |
        拖拽根任务（level 1）时：
        1. 自动收缩该任务的所有子任务
        2. 只显示根任务，子任务已隐藏
        3. 简化逻辑：不需要判断水平拖拽方向
      
      implementation: |
        在 `onDragStarted` 回调中：
        
        ```dart
        onDragStarted: () {
          final taskMap = {for (final t in filteredTasks) t.id: t};
          final taskLevel = getTaskLevel(task, taskMap);
          
          if (taskLevel == 1) {
            // 根任务：收缩所有子任务
            final expandedNotifier = ref.read(inboxExpandedTaskIdProvider.notifier);
            final currentExpanded = Set<int>.from(expandedNotifier.state);
            // 移除该任务的所有子任务的展开状态
            // ... 收缩逻辑
          }
          
          dragNotifier.startDrag(task, Offset.zero);
        }
        ```
    
    child_task_level_2_3:
      overview: |
        拖拽子任务（level 2/3）时：
        1. 检查任务是否展开，未展开则禁止拖拽
        2. 如果拖拽的任务有子任务，先自动收缩它们
        3. 允许拖拽，但只能在其父任务的扩展区域内
      
      implementation: |
        在 `onDragStarted` 回调中：
        
        ```dart
        onDragStarted: () {
          final taskMap = {for (final t in filteredTasks) t.id: t};
          final taskLevel = getTaskLevel(task, taskMap);
          
          if (taskLevel > 1) {
            // 子任务：检查是否展开
            final isExpanded = expandedTaskIds.contains(task.id);
            if (!isExpanded) {
              // 禁止拖拽未展开的任务
              return; // 或显示提示
            }
            // 收缩自己的子任务
            // ... 收缩逻辑
          }
          
          dragNotifier.startDrag(task, Offset.zero);
        }
        ```

  expanded_area_detection:
    overview: |
      检测子任务是否移动出父任务的扩展区域。
      如果移出扩展区，自动提升为根任务（level 1），修改 sortIndex，结束拖拽。
      
      扩展区定义：
      - 父任务的所有子任务（在扁平化列表中连续出现）
      - 如果父任务未展开，所有子任务都不在扁平化列表中，此时拖拽目标肯定不在扩展区内
    
    implementation: |
      在 `onHover` 回调中检测：
      
      ```dart
      /// 检查子任务是否移动出父任务的扩展区
      /// 
      /// [task] 被拖拽的子任务
      /// [hoveredTaskId] 当前悬停的任务 ID（如果是任务表面）
      /// [hoveredInsertionIndex] 当前悬停的插入位置索引（如果是插入间隔）
      /// [flattenedTasks] 扁平化任务列表
      /// [taskMap] 任务映射
      /// 返回 true 如果移动出扩展区，应该提升为 level 1
      bool _isMovedOutOfExpandedArea(
        Task task,
        int? hoveredTaskId,
        int? hoveredInsertionIndex,
        List<FlattenedTaskNode> flattenedTasks,
        Map<int, Task> taskMap,
      ) {
        if (task.parentId == null) {
          return false; // 根任务不存在扩展区
        }
        
        // 找到父任务
        final parentTask = taskMap[task.parentId];
        if (parentTask == null) {
          return false;
        }
        
        // 找到父任务的所有子任务在扁平化列表中的范围
        // ... 检测逻辑
        
        // 检查拖拽目标是否在扩展区内
        // ... 判断逻辑
      }
      ```
      
      当检测到移出扩展区时：
      
      ```dart
      // 在 onHover 或 onDragUpdate 中检测
      if (_isMovedOutOfExpandedArea(...)) {
        // 自动提升为 level 1
        await _promoteToRoot(task, ref);
        dragNotifier.endDrag(); // 结束拖拽
      }
      ```

  yielding_animation:
    overview: |
      让位动画只在同级任务之间进行：
      - 根任务之间：只在根任务列表中让位
      - 子任务之间：只在同一父任务的子任务列表中让位
      
      这样可以避免跨层级让位导致的空白间隔问题。
    
    implementation: |
      修改 `_calculateYieldingTransform` 方法：
      
      ```dart
      Matrix4? _calculateYieldingTransform({
        required int index,
        required int draggedTaskIndex,
        required int hoveredInsertionIndex,
        required int totalTasks,
        required int? draggedTaskLevel,
        required int? currentTaskLevel,
        required int? draggedTaskParentId,
        required int? currentTaskParentId,
      }) {
        // 只对同级任务进行让位
        if (draggedTaskLevel != currentTaskLevel) {
          return null; // 不同层级，不让位
        }
        
        // 如果是子任务，检查是否是同一父任务
        if (draggedTaskLevel! > 1) {
          if (draggedTaskParentId != currentTaskParentId) {
            return null; // 不同父任务，不让位
          }
        }
        
        // 原有的让位逻辑
        // ... 计算 transform
      }
      ```

  insertion_drop_logic:
    overview: |
      简化插入间隔的逻辑：
      - 拖拽子任务到插入间隔时，直接使用 `beforeTask.parentId` 作为新 `parentId`
      - 和 `beforeTask` 同级，改变 `sortIndex`，触发让位动画
    
    implementation: |
      修改 `_handleInsertionDrop` 方法：
      
      ```dart
      Future<TaskDragIntentResult> _handleInsertionDrop(
        Task draggedTask,
        Task? beforeTask,
        Task? afterTask,
        String targetType,
        WidgetRef ref,
      ) async {
        // ... 获取服务
        
        int? aboveTaskParentId;
        double newSortIndex;
        
        if (targetType == 'first') {
          // 顶部插入：成为根任务
          aboveTaskParentId = null;
          newSortIndex = SortIndexCalculator.insertAtFirst(beforeTask?.sortIndex);
        } else if (targetType == 'last') {
          // 底部插入：使用 beforeTask.parentId
          aboveTaskParentId = beforeTask?.parentId;
          newSortIndex = SortIndexCalculator.insertAtLast(beforeTask?.sortIndex);
        } else {
          // 中间插入：使用 beforeTask.parentId（和 beforeTask 同级）
          aboveTaskParentId = beforeTask?.parentId;
          newSortIndex = SortIndexCalculator.insertBetween(
            beforeTask!.sortIndex,
            afterTask!.sortIndex,
          );
        }
        
        // 统一使用 moveToParent 处理
        await taskHierarchyService.moveToParent(
          taskId: draggedTask.id,
          parentId: aboveTaskParentId,
          sortIndex: newSortIndex,
          clearParent: aboveTaskParentId == null,
        );
        
        return TaskDragIntentResult.success(...);
      }
      ```

implementation_plan:
  phase_1_level_system:
    name: "实现 level 系统和 sortIndex 计算类"
    tasks:
      - "在 `hierarchy_utils.dart` 中添加 `getTaskLevel` 函数"
      - "创建 `sort_index_calculator.dart` 文件，实现 `SortIndexCalculator` 类"
      - "添加单元测试验证 level 计算和 sortIndex 计算"
    
    files_to_create:
      - "lib/presentation/tasks/utils/sort_index_calculator.dart"
    
    files_to_modify:
      - "lib/presentation/tasks/utils/hierarchy_utils.dart"
      - "test/unit/presentation/tasks/utils/sort_index_calculator_test.dart"
    
    estimated_effort: "1-2 hours"

  phase_2_drag_start_logic:
    name: "实现拖拽开始时的逻辑"
    tasks:
      - "在 `onDragStarted` 中根据 level 执行不同逻辑"
      - "根任务：自动收缩所有子任务"
      - "子任务：检查是否展开，收缩自己的子任务"
      - "添加展开状态检查，禁止拖拽未展开的任务"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
      - "lib/core/providers/inbox_drag_provider.dart"
    
    estimated_effort: "2-3 hours"

  phase_3_expanded_area_detection:
    name: "实现扩展区检测和自动提升逻辑"
    tasks:
      - "实现 `_isMovedOutOfExpandedArea` 方法"
      - "在 `onHover` 回调中检测是否移出扩展区"
      - "实现自动提升为根任务的逻辑"
      - "测试移出扩展区的场景"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
    
    estimated_effort: "3-4 hours"

  phase_4_yielding_animation:
    name: "修复让位动画，只在同级任务之间"
    tasks:
      - "修改 `_calculateYieldingTransform` 方法"
      - "添加层级和父任务检查"
      - "确保只在同级任务之间让位"
      - "测试跨层级拖拽的场景"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
    
    estimated_effort: "2-3 hours"

  phase_5_insertion_drop_logic:
    name: "简化插入间隔的逻辑"
    tasks:
      - "修改 `_handleInsertionDrop` 方法"
      - "使用 `SortIndexCalculator` 替换硬编码"
      - "简化逻辑：直接使用 `beforeTask.parentId`"
      - "移除水平拖拽判断逻辑"
    
    files_to_modify:
      - "lib/presentation/inbox/views/inbox_task_list.dart"
      - "lib/presentation/inbox/inbox_drag_target.dart"
    
    estimated_effort: "2-3 hours"

  phase_6_testing:
    name: "测试和验证"
    tasks:
      - "编写单元测试和集成测试"
      - "测试各种拖拽场景"
      - "验证让位动画的正确性"
      - "验证自动提升逻辑"
    
    files_to_modify:
      - "test/unit/presentation/inbox/views/inbox_task_list_test.dart"
      - "test/integration/inbox_drag_test.dart"
    
    estimated_effort: "3-4 hours"

total_estimated_effort: "13-19 hours"

acceptance_criteria:
  - |
    1. **level 系统**：
       - `getTaskLevel` 函数正确计算任务的层级（1/2/3）
       - 项目和里程碑不计入层级深度
   
  - |
    2. **sortIndex 计算**：
       - `SortIndexCalculator` 类提供统一的 API
       - 所有 sortIndex 计算都使用该类，无硬编码
   
  - |
    3. **拖拽根任务**：
       - 拖拽开始时自动收缩所有子任务
       - 拖拽过程中只显示根任务
       - 让位动画只在根任务之间进行
   
  - |
    4. **拖拽子任务**：
       - 未展开的任务禁止拖拽
       - 只能在父任务的扩展区域内拖拽
       - 移出扩展区自动提升为根任务
   
  - |
    5. **让位动画**：
       - 只在同级任务之间让位
       - 没有空白间隔
       - 任务连续排列

risks:
  - name: "扩展区检测逻辑复杂"
    mitigation: |
      仔细设计扩展区检测算法，确保正确识别父任务的子任务范围
      添加充分的单元测试验证边界情况
  
  - name: "自动提升可能影响用户体验"
    mitigation: |
      通过测试确保自动提升的时机合理
      如果用户反馈不好，可以改为提示用户

dependencies:
  - "lib/presentation/tasks/utils/hierarchy_utils.dart"
  - "lib/presentation/inbox/views/inbox_task_list.dart"
  - "lib/core/constants/task_constants.dart"

related_documents:
  - "documents/spec/projects/tasks/design/251201-unified-drag-system.yaml"
  - "documents/spec/projects/tasks/iteration/251201-unified-drag-system.yaml"

