meta:
  id: "251201-reorderable-drag-target-conflict"
  title: "修复 ReorderableListView 中 DragTarget 拖拽移入/移出功能失效问题"
  status: draft
  owner: "AI Assistant"
  created_at: "2025-11-01"

background:
  problem: |
    在重构 Inbox 页面拖拽宽度修复后，将 `ReorderableDragStartListener` 移到最外层包裹整个 item，
    导致拖拽移入和移出功能失效：
    1. 拖拽任务到目标任务上时，目标任务不会变色（hover 效果失效）
    2. 松手后源任务回到原地，拖拽未被接受
    3. `TaskDragIntentTarget.surface` 中的 `DragTarget` 无法接收到拖拽事件
    4. 跨区域拖拽和成为子任务的功能受到影响
    
    根本原因：
    - `ReorderableDragStartListener` 包裹了整个 item，包括 `TaskDragIntentTarget.surface`
    - `ReorderableDragStartListener` 使用 `ReorderableListView` 的拖拽系统，可能会拦截或阻止拖拽事件传递
    - `DragTarget` 在 `ReorderableDragStartListener` 内部时，可能无法接收到来自其他 item 的拖拽事件
    - Flutter 的手势系统优先级导致 `ReorderableDragStartListener` 的拖拽手势优先于 `DragTarget` 的拖拽接收

  goal: |
    - 修复拖拽移入/移出功能，确保 `DragTarget` 能够正常接收拖拽事件
    - 保持 `ReorderableDragStartListener` 在最外层的结构（用于列表内部排序）
    - 确保跨区域拖拽和成为子任务功能正常工作
    - 保持与 Tasks 页面的行为一致性

technical_analysis:
  current_structure:
    Inbox:
      - ReorderableListView.builder
        - ReorderableDragStartListener (最外层)
          - InboxTaskTile
            - DismissibleTaskTile
              - TaskTileContent
                - TaskDragIntentTarget.surface (DragTarget)
                  - StandardDraggable (LongPressDraggable)
                    - TaskRowContent
    
    Tasks:
      - ReorderableListView.builder
        - ReorderableDragStartListener (最外层)
          - TaskWithParentChain
            - TaskTreeTile
              - TaskLeafTile
                - DismissibleTaskTile
                  - TaskTileContent
                    - TaskDragIntentTarget.surface (DragTarget)
                      - StandardDraggable (LongPressDraggable)
                        - TaskRowContent

  conflict_mechanism: |
    1. 列表内部排序：
       - 使用 `ReorderableDragStartListener` 的立即拖拽（从整个 item 拖拽）
       - 触发 `ReorderableListView` 的 `onReorder` 回调
       - 工作正常
    
    2. 跨区域拖拽/成为子任务：
       - 使用 `StandardDraggable` 的 `LongPressDraggable`（从拖拽图标长按拖拽）
       - 需要 `TaskDragIntentTarget.surface` 的 `DragTarget` 接收拖拽事件
       - 当前失效：`ReorderableDragStartListener` 可能阻止了事件传递

  hypothesis:
    - 方案 A：`ReorderableDragStartListener` 拦截了所有拖拽手势，导致内部的 `DragTarget` 无法接收事件
    - 方案 B：Flutter 的手势竞争机制导致 `ReorderableListView` 的手势优先于 `DragTarget`
    - 方案 C：`DragTarget` 需要与 `ReorderableDragStartListener` 在同一层级或外层才能正常工作

solutions:
  solution_1_restructure:
    name: "调整结构：将 DragTarget 移到 ReorderableDragStartListener 外层"
    description: |
      将 `TaskDragIntentTarget.surface` 移到 `ReorderableDragStartListener` 外层，
      这样 `DragTarget` 就不会被 `ReorderableDragStartListener` 包裹。
    
    structure:
      - ReorderableListView.builder
        - TaskDragIntentTarget.surface (DragTarget)
          - ReorderableDragStartListener
            - InboxTaskTile / TaskWithParentChain
    
    pros:
      - DragTarget 能够直接接收拖拽事件
      - 不依赖 Flutter 内部手势传递机制
      - 逻辑清晰，层级明确
    
    cons:
      - 需要修改 `InboxTaskList` 和 `TaskSectionTaskModeList` 的结构
      - 可能影响列表排序的拖拽行为
      - 需要确保 `ReorderableDragStartListener` 在 `DragTarget` 内部时仍能正常工作
    
    implementation:
      - 修改 `InboxTaskList.itemBuilder`，将 `TaskDragIntentTarget.surface` 移到外层
      - 修改 `TaskSectionTaskModeList.itemBuilder`，同样调整结构
      - 测试列表内部排序功能是否仍然正常
      - 测试跨区域拖拽和成为子任务功能是否恢复

  solution_2_gesture_detector:
    name: "使用 GestureDetector 或 Listener 显式传递事件"
    description: |
      在 `TaskDragIntentTarget.surface` 中使用 `Listener` 或 `GestureDetector`
      来显式监听拖拽事件，并手动触发 `DragTarget` 的回调。
    
    implementation:
      - 在 `TaskDragIntentTarget` 中添加 `Listener` 监听 `PointerMoveEvent`
      - 检测拖拽事件并手动触发 hover 效果
      - 可能需要在 `StandardDraggable` 中添加事件通知机制
    
    pros:
      - 可以绕过手势竞争问题
      - 不需要大幅调整结构
    
    cons:
      - 实现复杂，需要手动处理事件传递
      - 可能与 Flutter 的内部机制冲突
      - 维护成本高

  solution_3_separate_handles:
    name: "分离拖拽手柄：列表排序和跨区域拖拽使用不同的触发区域"
    description: |
      明确区分两种拖拽场景：
      - 列表内部排序：从整个 item 拖拽（使用 `ReorderableDragStartListener`）
      - 跨区域拖拽：只从拖拽图标长按拖拽（使用 `StandardDraggable`）
      
      通过手势区域分离来避免冲突。
    
    implementation:
      - 确保 `StandardDraggable` 的 `handle` 区域（拖拽图标）不被 `ReorderableDragStartListener` 覆盖
      - 或者使用 `IgnorePointer` 或 `AbsorbPointer` 来控制手势优先级
      - 确保 `DragTarget` 能够接收到来自 `LongPressDraggable` 的拖拽事件
    
    pros:
      - 用户交互明确，两种拖拽方式区分清晰
      - 不需要大幅调整结构
    
    cons:
      - 需要确保手势区域正确分离
      - 可能仍然存在手势冲突问题
      - 需要仔细测试边界情况

  solution_4_disable_reorderable_for_external_drag:
    name: "动态禁用 ReorderableDragStartListener 的拖拽，当检测到跨区域拖拽时"
    description: |
      在 `StandardDraggable` 的 `LongPressDraggable` 启动时，临时禁用
      `ReorderableDragStartListener` 的功能，确保 `DragTarget` 能够接收事件。
    
    implementation:
      - 添加状态管理来跟踪当前是否在进行跨区域拖拽
      - 当 `LongPressDraggable` 启动时，通过 Provider 通知其他组件
      - `ReorderableDragStartListener` 监听此状态，在跨区域拖拽时禁用自身
      - 拖拽结束后恢复 `ReorderableDragStartListener` 的功能
    
    pros:
      - 可以完全避免手势冲突
      - 保持当前的结构不变
    
    cons:
      - 需要添加状态管理
      - 实现复杂，需要协调多个组件
      - 可能影响列表排序的用户体验

recommended_solution: "solution_1_restructure"
reason: |
  1. 结构最清晰，逻辑最直观
  2. DragTarget 在外层能够直接接收所有拖拽事件，不依赖内部传递
  3. 符合 Flutter 的最佳实践：DragTarget 应该包裹需要接收拖拽的区域
  4. 实现相对简单，只需要调整 itemBuilder 的结构
  5. 不会引入复杂的状态管理

implementation_plan:
  phase_1_analysis:
    - 确认 Tasks 页面是否也存在同样的问题
    - 测试 Tasks 页面的拖拽移入/移出功能是否正常工作
    - 如果 Tasks 正常，对比差异找出原因
    - 如果 Tasks 也有问题，说明是通用问题

  phase_2_prototype:
    - 在 Inbox 页面实现解决方案 1 的 prototype
    - 测试列表内部排序是否正常
    - 测试拖拽移入/移出功能是否恢复
    - 测试跨区域拖拽和成为子任务功能

  phase_3_refinement:
    - 根据测试结果调整实现
    - 确保所有功能正常工作
    - 优化代码结构和性能

  phase_4_apply_to_tasks:
    - 如果 Tasks 页面也存在问题，应用相同的修复
    - 确保两个页面的行为一致

  phase_5_testing:
    - 全面的功能测试
    - 边缘情况测试
    - 性能测试

risks:
  - 调整结构可能影响列表排序的拖拽行为
  - 需要确保 `ReorderableDragStartListener` 在 `DragTarget` 内部时仍能正常工作
  - 可能需要处理手势优先级问题

alternatives:
  - 如果方案 1 不可行，考虑方案 3（分离拖拽手柄）
  - 如果所有方案都有问题，可能需要重新设计拖拽系统架构

