# 拖拽插入间隔线设计方案

## 文档信息

- **创建日期**: 2025-11-03
- **目标**: 用间隔线替代让位动画，简化拖拽实现，提升性能和用户体验
- **适用范围**: Tasks 页面和 Inbox 页面
- **状态**: 设计阶段

## 1. 背景和目标

### 1.1 当前方案的问题

当前拖拽实现使用**让位动画**（Yielding Animation）来提供视觉反馈：
- 当拖拽任务到新位置时，其他任务通过 Transform 动画移动让位
- 实现复杂，涉及大量索引转换、层级判断、边界检测
- 存在跨区域拖拽时的状态同步问题
- 性能开销大（大量 Transform 动画同时执行）
- 边界溢出问题难以处理

### 1.2 新方案的目标

采用**间隔线**（Insertion Line）替代让位动画：
- **简化实现**：删除约 200-300 行复杂动画逻辑
- **提升性能**：无需大量 Transform 计算和渲染
- **解决边界问题**：无溢出风险，无需复杂的边界处理
- **统一体验**：Inbox 和 Tasks 使用相同的视觉反馈方式
- **符合主流**：参考 Trello、Notion、Linear 等主流应用的实现

## 2. 设计方案

### 2.1 视觉设计

#### 2.1.1 间隔线样式

**基础设计**：
- **视觉线高度**: 3px（仅在悬停时显示）
- **命中区域高度**: 10px（用于容错，未悬停时不可见）
- **左右边距**: 16px（与任务卡片水平 padding 对齐）
- **颜色**: 使用主题色（`colorScheme.primary`，海盐蓝）
- **圆角**: 2px

**阴影效果**：
- 采用轻微阴影增强视觉层次和容错感知
- 阴影参数：
  - 颜色: `primary.withAlpha(0.3)` (浅色主题) / `primary.withAlpha(0.4)` (深色主题)
  - 模糊半径: 4px
  - 扩散半径: 1px
  - 偏移: `Offset(0, 1)` (轻微向下)

#### 2.1.2 状态变化

**未悬停状态**：
- 间隔线完全不可见
- 保持 10px 透明命中区域用于拖拽检测
- 用户无法感知到插入目标的存在

**悬停状态**：
- 显示 3px 带阴影的间隔线
- 使用动画过渡（120ms，与现有 hover 动画时长一致）
- 视觉反馈清晰明确

### 2.2 布局调整

#### 2.2.1 间距优化

为了增大命中区域而不改变总视觉间距，进行以下调整：

**任务卡片垂直 padding**：
- 从 8px 减少到 7px
- 略微紧凑，但在可接受范围内
- 符合 Material Design 4dp 网格系统（7px ≈ 1.75dp）

**插入目标命中区域**：
- 从 8px 增加到 10px
- 提升 25% 的容错空间
- 用户更容易命中插入位置

**计算结果**：
```
原方案：
- 任务上 padding: 8px
- 插入区域: 8px
- 任务下 padding: 8px
- 总间距: 24px

新方案：
- 任务上 padding: 7px
- 插入区域: 10px
- 任务下 padding: 7px
- 总间距: 24px (保持不变)
```

**任务卡片总高度调整**：
- 从 60px 调整到 59px（减少 1px）
- 内容区域: 59px - 14px = 45px（比原来多 1px，视觉影响可忽略）

### 2.3 状态管理

#### 2.3.1 需要保留的状态

**Tasks 页面（`TasksDragState`）**：
- `draggedTask`: 当前拖拽的任务
- `isDragging`: 是否正在拖拽
- `hoveredInsertionIndex`: 当前悬停的插入位置索引
- `hoveredInsertionSection`: 当前悬停的插入位置所在 section（跨区域拖拽）
- `committedInsertionIndex`: 已提交的插入位置索引（用于拖拽结束时的操作）
- `committedInsertionSection`: 已提交的插入位置所在 section
- `dragStartPosition`: 拖拽起始位置
- `currentDragPosition`: 当前拖拽位置
- `horizontalOffset`: 水平位移（用于向左拖拽升级子任务）
- `verticalOffset`: 垂直位移

**Inbox 页面（`InboxDragState`）**：
- 类似的字段结构
- 不需要 `hoveredInsertionSection`（Inbox 无分区概念）

#### 2.3.2 可以删除的状态

- 不再需要让位动画相关的状态
- 不需要记录每个任务的 Transform 状态

#### 2.3.3 展开状态管理

**`tasksSectionExpandedTaskIdProvider`（Tasks 页面）**：
- 每个 section 独立管理展开的任务 ID 集合（`Set<int>`）
- 拖拽根任务时，清空该 section 的展开状态（`expandedTaskIds = {}`）
- 展开一个根任务时，移除其他根任务的展开状态（只保留当前展开的根任务）

**`inboxExpandedTaskIdProvider`（Inbox 页面）**：
- 类似的管理方式，但 Inbox 可能允许多个根任务同时展开（根据具体需求）

**层级状态交互规则**：
- 拖拽根任务开始时：自动收缩所有根任务
- 点击展开根任务时：收缩其他根任务，只展开当前根任务
- 子任务的展开/收缩独立管理，不受根任务展开状态影响

### 2.4 交互逻辑

#### 2.4.1 拖拽流程

1. **拖拽开始**：
   - 用户长按任务卡片
   - `onDragStarted` 触发
   - 更新 `draggedTask` 和 `isDragging = true`
   - 任务卡片变为半透明（`childWhenDraggingOpacity`）

2. **拖拽移动**：
   - `onDragUpdate` 持续触发
   - 更新 `currentDragPosition`、`horizontalOffset`、`verticalOffset`
   - 检测鼠标/手指是否进入插入目标区域
   - 进入时：调用 `updateInsertionHover(insertionIndex, section)`
   - 更新 `hoveredInsertionIndex` 和 `hoveredInsertionSection`
   - 对应的插入目标显示间隔线（视觉反馈）

3. **拖拽结束**：
   - `onDragEnd` 触发
   - 检查 `hoveredInsertionIndex` 或 `committedInsertionIndex`
   - 如果有有效插入位置，执行插入操作（更新 `sortIndex`、`dueAt` 等）
   - 如果没有插入位置，检查是否满足向左拖拽升级子任务的条件
   - 清除所有拖拽状态
   - **层级处理**：如果拖拽的是根任务，自动收缩所有根任务（重置展开状态）

#### 2.4.1.1 任务层级管理规则

**规则 1：拖拽根任务时自动收缩所有根任务**

**目的**：简化拖拽逻辑，避免拖动到子任务需要复杂判断

**实现逻辑**：
- 检测被拖拽的任务是否为根任务（`level == 1` 且 `parentId == null`）
- 当 `onDragStarted` 触发且拖拽的是根任务时：
  - 清空当前 section 的所有展开状态（`expandedTaskIds = {}`）
  - 所有根任务收缩，只显示根任务本身
- 这样确保拖拽时只有根任务可见，插入目标判断简单明了

**规则 2：展开一个根任务时，其他根任务自动收缩**

**目的**：避免拖拽子任务套其他任务的子任务的复杂情况

**实现逻辑**：
- 当用户点击展开/收缩按钮时：
  - 如果要展开任务 A：
    - 如果任务 A 是根任务（`level == 1`）：
      - 先收缩所有其他根任务（`expandedTaskIds.removeAll(其他根任务ID)`）
      - 再展开任务 A（`expandedTaskIds.add(A.id)`）
    - 如果要收缩任务 A：
      - 直接收缩任务 A（`expandedTaskIds.remove(A.id)`）
- 确保同一时刻只有一个根任务处于展开状态
- 子任务的展开不受此规则限制（子任务可以独立展开）

**规则 3：子任务的拖拽操作**

**同一任务的子任务可以**：
- **调整排序**：在同一父任务下的子任务之间拖动，调整 `sortIndex`
- **成为三级任务**：将子任务拖动到另一个子任务上，成为该子任务的子任务（三级任务）

**实现逻辑**：
- 检测被拖拽的任务是否为子任务（`level == 2`，即 `parentId != null`）
- 如果拖到另一个子任务上（`level == 2`）：
  - 检查目标任务的 `level`：
    - 如果 `level == 2`：可以成为三级任务（`level == 3`）
    - 如果 `level == 3`：不允许（因为最多三级）
- 如果拖到根任务上：
  - 成为该根任务的子任务（`level == 2`）

**规则 4：任务最多不超过三级**

**目的**：保持层级结构清晰，避免过深嵌套

**实现逻辑**：
- 在所有拖拽操作中检查目标层级：
  - 如果被拖拽任务的 `level` 已经是 3：不允许拖到其他任务的子任务下
  - 如果目标任务的 `level` 是 3：不允许将任务拖到该任务下（因为会变成 4 级）
- 在 `canAccept` 或 `onPerform` 中验证：
  ```dart
  // 伪代码
  if (targetTask.level >= 3) {
    return false; // 不允许成为四级任务
  }
  if (draggedTask.level == 3 && targetTask.level == 2) {
    return false; // 三级任务不能再成为其他任务的子任务
  }
  ```

#### 2.4.2 跨区域拖拽（Tasks 页面）

**从区域 A 拖到区域 B**：
1. 拖拽任务进入区域 B 的插入目标
2. `hoveredInsertionSection` 更新为区域 B
3. 区域 B 的插入目标显示间隔线
4. 区域 A 中的原任务保持半透明（不移动）
5. 拖拽结束时：
   - 更新任务的 `dueAt` 为区域 B 的结束时间
   - 更新 `sortIndex` 到区域 B 的相应位置
   - 任务从区域 A 移动到区域 B

**关键点**：
- 不需要跨区域占位符管理
- 不需要跨区域让位动画
- 逻辑清晰简单

#### 2.4.3 边界情况处理

**场景 1：空区域的边界拖拽**

**问题描述**：
- 区域 B 没有任何任务，当前会完全隐藏（`SizedBox.shrink()`）
- 如果拖拽到区域 B，无法显示间隔线（因为区域 B 的插入目标不存在）

**解决方案**：
- 当检测到跨区域拖拽到空区域时：
  1. 临时创建区域 B 的占位插入目标（仅用于显示间隔线）
  2. 或者在拖拽悬停到区域边界时，显示区域 B 的标题区域（如果存在）
  3. 在区域 B 的标题下方显示间隔线，表示可以插入到空区域

**实现逻辑**：
```
拖拽检测：
- 检测拖拽位置是否在两个区域之间的边界（分区标题区域）
- 如果拖拽到区域 B 的标题区域，且区域 B 为空：
  - 在区域 B 的标题下方显示间隔线
  - `hoveredInsertionSection = B`
  - `hoveredInsertionIndex = 0` (空区域的第一个位置)
```

**场景 2：区域不可见（需要滚动）**

**问题描述**：
- 区域 B 不在当前可视区域内
- 拖拽到屏幕边缘时，需要自动滚动到区域 B 才能显示间隔线

**解决方案**：
- **边缘自动滚动**变得更重要：
  1. 检测拖拽接近屏幕边缘
  2. 根据拖拽方向判断目标区域
  3. 自动滚动到目标区域，使其可见
  4. 目标区域可见后，间隔线才能正确显示

**实现逻辑**：
```
边缘滚动检测：
- 拖拽接近顶部：向上滚动，检查是否有上一个区域
- 拖拽接近底部：向下滚动，检查是否有下一个区域
- 滚动到目标区域的第一个插入目标位置
- 确保目标区域的插入目标进入可视区域
```

**场景 3：区域边界模糊（拖到边界时的判断）**

**问题描述**：
- 拖拽到区域 A 的底部和区域 B 的顶部之间
- 需要明确判断是插入到区域 A 的底部还是区域 B 的顶部

**解决方案**：
- 基于拖拽位置相对于分区标题的位置判断：
  - 如果拖拽位置在区域 A 的底部插入目标内 → 插入到区域 A 底部
  - 如果拖拽位置在区域 B 的顶部插入目标内 → 插入到区域 B 顶部
  - 如果拖拽位置在两个区域之间（分区标题区域）：
    - 根据拖拽方向判断：
      - 从上往下拖：插入到区域 B 顶部
      - 从下往上拖：插入到区域 A 底部

**实现逻辑**：
```
边界判断：
- 检测拖拽位置是否在分区标题区域
- 如果在标题区域：
  - 计算拖拽的垂直方向（从 dragStartPosition 到 currentDragPosition）
  - 向上拖拽：插入到上方区域的底部
  - 向下拖拽：插入到下方区域的顶部
```

**场景 4：区域顶部的特殊处理**

**问题描述**：
- 拖拽到区域 B 的顶部时，间隔线应该显示在区域 B 的第一个任务之前
- 如果区域 B 的第一个任务不在可视区域内，间隔线也无法显示

**解决方案**：
- 区域顶部插入目标始终存在（即使没有任务，也有 `insertionFirst`）
- 结合边缘自动滚动，确保顶部插入目标可见
- 或者：在拖拽接近区域边界时，提前滚动到目标区域

**场景 5：区域底部的特殊处理**

**问题描述**：
- 拖拽到区域 B 的底部时，间隔线应该显示在区域 B 的最后一个任务之后
- 如果区域 B 的最后一个任务不在可视区域内，间隔线也无法显示

**解决方案**：
- 区域底部插入目标始终存在（`insertionLast`）
- 结合边缘自动滚动，确保底部插入目标可见

#### 2.4.4 插入位置检测

**插入目标类型**：
- `first`: 列表开头（`insertionIndex = 0`）
- `between`: 两个任务之间（`insertionIndex = 当前任务索引`）
- `last`: 列表结尾（`insertionIndex = -1` 或 `tasks.length`）

**位置计算**：
- 基于任务的全局列表索引（`flattenedTasks` 或 `rootTasks`）
- 不需要复杂的索引转换（因为不再需要让位动画的索引映射）

**跨区域时的位置计算**：
- 目标区域的插入索引：基于目标区域的 `flattenedTasks` 或 `rootTasks` 计算
- 不需要考虑源区域的索引（因为任务会移动到新区域）

#### 2.4.5 层级状态管理交互

**展开/收缩交互**：
- 用户点击根任务的展开/收缩按钮
- 系统自动收缩其他根任务，只保留当前点击的根任务展开
- 子任务可以独立展开/收缩，不受影响

**拖拽时的层级状态**：
- 拖拽根任务：所有根任务自动收缩，简化拖拽判断
- 拖拽子任务：保持当前展开状态，允许在展开的子任务区域内操作

**视觉反馈**：
- 展开的根任务显示所有子任务（缩进显示）
- 收缩的根任务只显示根任务本身
- 展开状态使用 `expandedTaskIds` Provider 管理（按 section 分区）

### 2.5 边缘自动滚动（可选）

#### 2.5.1 需求

当拖拽接近屏幕顶部或底部时，自动滚动列表，确保目标区域可见。

#### 2.5.2 实现逻辑

**触发条件**：
- 拖拽位置接近屏幕顶部（距离 < 120px）
- 或接近屏幕底部（距离 < 120px）

**滚动行为**：
- 向上滚动：拖拽接近顶部时
- 向下滚动：拖拽接近底部时
- 滚动速度：根据距离边缘的距离动态调整（越近越快，最大 30px/次）
- 使用 `jumpTo` 而非 `animateTo`，确保实时响应

**停止条件**：
- 拖拽远离边缘区域
- 拖拽结束（`onDragEnd`）
- 到达列表顶部/底部边界

**注意**：
- 边缘自动滚动在间隔线方案下变得更加重要
- 因为需要确保目标区域的插入目标可见，才能正确显示间隔线
- 特别是跨区域拖拽时，自动滚动是必需的
- 空区域的边界拖拽也需要依赖自动滚动来显示区域标题

**边界拖拽的特殊处理**：
- 当拖拽接近区域边界时，优先滚动到目标区域
- 确保目标区域的插入目标（顶部或底部）进入可视区域
- 这样间隔线才能正确显示在预期的位置

## 3. 实现范围

### 3.1 需要修改的文件

#### 3.1.1 共同组件（核心修改）

**`lib/presentation/common/drag/standard_drag_target.dart`**：
- 修改 `_buildDefaultInsertionZone` 方法
- 实现间隔线渲染逻辑
- 添加阴影效果
- 处理悬停/未悬停状态切换

#### 3.1.2 主题和常量

**`lib/core/constants/drag_constants.dart`**：
- 添加间隔线相关常量：
  - `insertionLineHitArea`: 10px（命中区域高度）
  - `insertionLineHeight`: 3px（视觉线高度）
  - `insertionLineMargin`: 16px（左右边距）
- 删除或保留 `insertionTargetHeight`（如果仍用于向后兼容）
- 调整 `taskHeight`: 从 60px 到 59px

**`lib/core/theme/app_spacing_tokens.dart`**：
- 修改 `taskTileVerticalPadding`: 从 8.0 到 7.0

**`lib/core/theme/drag_theme.dart`**：
- 添加间隔线相关属性（可选）：
  - `insertionLineColor`: 间隔线颜色
  - `insertionLineShadowAlpha`: 阴影透明度

#### 3.1.3 Tasks 页面

**`lib/presentation/tasks/views/tasks_section_task_list.dart`**：
- **删除**：
  - `_calculateYieldingTransform` 方法（约 60 行）
  - `_calculateInsertionTargetHeight` 方法（约 50 行）
  - 所有 `AnimatedContainer` 的 `transform` 计算逻辑（约 80 行）
- **简化**：
  - 任务卡片的渲染逻辑（移除 Transform）
  - `TaskDragIntentTarget.insertion` 的调用（移除 `expandedHeight` 参数）
  - `onDragUpdate` 中的日志输出
- **新增**：
  - 在 `onDragStarted` 中检测根任务拖拽，自动收缩所有根任务
  - 在展开/收缩按钮点击时，实现"展开一个根任务时其他根任务收缩"的逻辑
  - 在拖拽接受逻辑中，添加三级任务限制检查

#### 3.1.4 Inbox 页面

**`lib/presentation/inbox/views/inbox_task_list.dart`**：
- 类似的删除和简化操作
- 与 Tasks 页面保持一致

#### 3.1.5 边缘自动滚动（可选实现）

**`lib/presentation/tasks/views/tasks_section_task_list.dart`**：
- 在 `onDragUpdate` 中添加边缘检测逻辑
- 实现自动滚动方法

**`lib/presentation/inbox/views/inbox_task_list.dart`**：
- 类似的边缘自动滚动实现

### 3.2 不需要修改的文件

以下文件不需要修改，因为间隔线方案不影响其功能：
- 任务拖拽处理器（`tasks_drag_handler.dart`、拖拽相关的 provider）
- 任务数据模型和服务层
- 路由和导航相关代码

## 4. 实现步骤

### 4.1 第一阶段：核心组件改造

1. **修改 `StandardDragTarget`**：
   - 实现间隔线渲染
   - 添加阴影效果
   - 处理状态切换动画

2. **更新常量和主题**：
   - 添加间隔线常量
   - 调整间距令牌
   - 更新主题扩展（如需要）

3. **测试视觉效果**：
   - 验证间隔线显示正确
   - 检查阴影效果
   - 确认动画流畅

### 4.2 第二阶段：Tasks 页面改造

1. **删除让位动画代码**：
   - 删除 `_calculateYieldingTransform`
   - 删除 `_calculateInsertionTargetHeight`
   - 移除任务卡片的 Transform 逻辑

2. **简化插入目标调用**：
   - 移除 `expandedHeight` 参数
   - 简化相关逻辑

3. **测试拖拽功能**：
   - 同区域拖拽
   - 跨区域拖拽
   - 边界情况

### 4.3 第三阶段：Inbox 页面改造

1. **执行与 Tasks 页面相同的改造**
2. **确保两个页面行为一致**

### 4.4 第四阶段：边缘自动滚动（可选）

1. **实现边缘检测逻辑**
2. **实现自动滚动**
3. **测试各种场景**

### 4.5 第五阶段：测试和优化

1. **功能测试**：
   - 所有拖拽场景
   - 边界情况
   - 性能测试

2. **视觉测试**：
   - 不同主题（浅色/深色）
   - 不同设备尺寸
   - 动画流畅度

3. **用户体验测试**：
   - 拖拽容错性
   - 视觉反馈清晰度
   - 操作流畅度

## 5. 测试用例

### 5.1 基础拖拽测试

- [ ] 任务在同一区域内拖拽排序
- [ ] 任务拖拽到列表开头
- [ ] 任务拖拽到列表末尾
- [ ] 任务拖拽到两个任务之间

### 5.2 跨区域拖拽测试（Tasks 页面）

- [ ] 从"今天"拖到"明天"
- [ ] 从"明天"拖到"本周"
- [ ] 从"本周"拖到"本月"
- [ ] 从"本月"拖到"以后"
- [ ] 从"以后"拖回"今天"
- [ ] 拖到空区域的顶部（区域没有任务时的插入）
- [ ] 拖到空区域的底部（区域没有任务时的插入）
- [ ] 拖到区域顶部（目标区域的第一个任务不在可视区域）
- [ ] 拖到区域底部（目标区域的最后一个任务不在可视区域）
- [ ] 拖到区域边界（两个区域之间的分区标题区域）
- [ ] 从区域边界向上拖拽（应该插入到上方区域底部）
- [ ] 从区域边界向下拖拽（应该插入到下方区域顶部）

### 5.3 边界情况测试

- [ ] 拖拽到空列表区域（空区域的处理）
- [ ] 拖拽到只有一个任务的区域
- [ ] 快速连续拖拽多个任务
- [ ] 拖拽中途取消（移出列表区域）
- [ ] 拖拽到目标区域不在可视区域（需要自动滚动）
- [ ] 边缘自动滚动触发和停止
- [ ] 拖拽到列表最顶部（向上滚动边界）
- [ ] 拖拽到列表最底部（向下滚动边界）

### 5.4 层级管理测试

- [ ] 拖拽根任务时，所有根任务自动收缩
- [ ] 展开一个根任务时，其他根任务自动收缩
- [ ] 展开根任务后，只显示该根任务的子任务
- [ ] 收缩根任务后，子任务隐藏
- [ ] 同一任务的子任务可以通过拖动调整排序
- [ ] 子任务可以拖动到另一个子任务下成为三级任务
- [ ] 三级任务不能再成为其他任务的子任务（最多三级限制）
- [ ] 二级任务不能拖动到三级任务下（防止成为四级）
- [ ] 三级任务的展开/收缩功能正常
- [ ] 子任务的展开状态独立于根任务

### 5.5 视觉测试

- [ ] 间隔线正确显示在悬停位置
- [ ] 间隔线颜色符合主题
- [ ] 阴影效果正确
- [ ] 动画过渡流畅
- [ ] 未悬停时间隔线不可见

### 5.6 性能测试

- [ ] 大量任务（100+）拖拽流畅
- [ ] 无明显的性能下降
- [ ] 内存占用正常

## 6. 风险评估

### 6.1 潜在风险

1. **视觉效果变化**：
   - 用户可能习惯让位动画
   - **缓解措施**：间隔线提供清晰的视觉反馈

2. **容错性降低**：
   - 如果命中区域设置过小
   - **缓解措施**：增加到 10px，并添加阴影增强视觉引导

3. **兼容性问题**：
   - 如果某些设备上阴影效果不理想
   - **缓解措施**：提供降级方案（无阴影的纯色线）

### 6.2 回退方案

如果间隔线方案效果不理想，可以：
1. 保留让位动画作为备选
2. 通过配置切换两种方案
3. 渐进式迁移（先保留让位动画，逐步切换到间隔线）

## 7. 后续优化

### 7.1 可能的改进

1. **自适应间距**：
   - 根据设备尺寸调整命中区域大小

2. **动画增强**：
   - 间隔线出现时的缩放动画
   - 更丰富的视觉反馈

3. **无障碍支持**：
   - 为屏幕阅读器添加语义标签
   - 支持键盘拖拽

### 7.2 性能优化

1. **渲染优化**：
   - 只在悬停时创建间隔线 Widget
   - 使用 `RepaintBoundary` 隔离重绘

2. **状态优化**：
   - 减少不必要的状态更新
   - 优化事件处理频率

## 8. 参考资源

### 8.1 主流应用参考

- **Trello**: 使用蓝色插入线
- **Notion**: 使用浅灰色插入线
- **Linear**: 使用带阴影的插入线
- **Asana**: 列表视图使用插入线

### 8.2 设计规范

- Material Design 3: Drag and Drop Guidelines
- Flutter ReorderableListView: 官方实现参考

## 9. 总结

间隔线方案通过简化实现、提升性能、解决边界问题，为应用带来更好的拖拽体验。方案设计考虑了视觉一致性、用户体验和可维护性，是一个值得实施的改进方向。
