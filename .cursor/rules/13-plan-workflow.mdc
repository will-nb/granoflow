---
when: always
---

# 13-plan-workflow.mdc - Chat, Plan & Preview Workflow Rules

## Chat 机制规则

### Chat 触发条件
- 当用户在对话框中输入"chat"时，AI必须进入讨论模式
- 这是所有feature讨论和debug话题的起始点
- 不执行任何文件修改操作，专注于需求分析和意图理解

### Chat 执行流程

#### 1. 话题归纳
- 分析用户提出的feature需求或debug问题
- 总结核心需求和预期目标
- 识别技术难点和约束条件
- 明确讨论范围和边界

#### 2. 需求分析
- 深入理解用户意图和业务背景
- 分析技术可行性和实现复杂度
- 识别潜在风险和依赖关系
- 评估影响范围和资源需求

#### 3. 讨论引导
- 提出关键问题澄清需求细节
- 建议技术方案和实现路径
- 讨论设计权衡和最佳实践
- 引导用户明确具体需求

#### 4. 上下文准备
- 将讨论内容整理为结构化信息
- 准备传递给后续规则（preview/plan/step）的上下文
- 确保需求描述清晰、完整、可执行

### Chat 输出格式

```yaml
chat_summary:
  topic: "讨论主题"
  type: "feature|debug|refactor|optimization"
  user_intent: "用户的核心意图"
  
requirements:
  functional: ["功能需求1", "功能需求2"]
  non_functional: ["性能要求", "安全要求"]
  constraints: ["技术约束", "时间约束"]
  
technical_analysis:
  complexity: "low|medium|high"
  risk_level: "low|medium|high"
  dependencies: ["依赖项1", "依赖项2"]
  affected_areas: ["影响范围1", "影响范围2"]
  
next_steps:
  clarification_needed: ["需要澄清的问题"]
  suggested_approach: "建议的技术方案"
  recommended_rule: "preview|plan|step"
```

### Chat 执行原则

#### 专注讨论
- **不修改文件**：Chat阶段只进行讨论，不执行任何代码修改
- **深入分析**：充分理解需求，避免后续返工
- **主动提问**：发现模糊点时主动询问澄清

#### 需求导向
- **用户意图优先**：以用户的实际需求为准
- **业务价值导向**：关注功能对业务的价值
- **技术可行性**：评估技术实现的可行性

#### 上下文准备
- **结构化整理**：将讨论内容整理为结构化信息
- **完整传递**：确保后续规则能获得完整的上下文
- **避免信息丢失**：保留所有重要的讨论细节

### 与其他规则的关系

#### Chat → Preview
- Chat阶段的需求分析为Preview提供基础
- Preview基于Chat的讨论内容生成迭代预览

#### Chat → Plan  
- Chat阶段的技术分析为Plan提供实施指导
- Plan基于Chat的需求分析制定详细计划

#### Chat → Step
- Chat阶段的细节讨论为Step提供精确修改指导
- Step基于Chat的具体需求执行精确修改

## Plan & Preview 机制规则

### 双重触发机制

#### Preview 触发条件
- 当用户在聊天中提到"preview"时，AI必须判断是否准备总结之前的聊天内容，制定计划预览
- 执行流程：上下文分析 → 需求总结 → 文档影响分析 → 生成preview文档

#### Plan 触发条件
- 当用户在聊天中提到"plan"时，AI必须判断是否决定制定详细的迭代计划
- 执行流程：上下文分析 → 检查preview文档 → 基于模板生成plan文档 → 制定四大核心要素计划

### Preview 文档生成流程

#### 1. 前置工作检查

##### 1.1 代码状态检查
- **文件完整性**：检查相关代码文件是否存在且完整
- **语法检查**：运行 `flutter analyze` 确保代码语法正确
- **依赖检查**：确保所有依赖包已正确安装
- **编译检查**：运行 `flutter build` 确保代码可以编译

##### 1.2 测试状态检查
- **单元测试**：运行 `flutter test` 确保所有单元测试通过
- **集成测试**：运行 `flutter test integration_test` 确保集成测试通过
- **测试覆盖率**：检查测试覆盖率是否满足要求
- **测试失败分析**：如果测试失败，详细分析失败原因

##### 1.3 YAML一致性检查
- **架构文档检查**：检查 `documents/architecture/` 下的相关YAML文件
- **配置文档检查**：检查 `documents/config/` 下的相关YAML文件
- **代码实现对比**：将当前代码实现与YAML文档进行详细对比
- **不一致项记录**：记录所有发现的不一致项

##### 1.4 单项测试执行
- **功能测试**：对相关功能进行独立测试
- **边界测试**：测试边界条件和异常情况
- **性能测试**：检查性能是否满足要求
- **兼容性测试**：确保与现有功能的兼容性

##### 1.5 测试失败处理
- **失败原因分析**：详细分析测试失败的具体原因
- **修复建议**：提供具体的修复建议和步骤
- **退出条件**：如果无法修复，退出并说明原因
- **重试机制**：提供重试机制和修复路径

##### 1.6 前置工作检查执行顺序
1. **代码状态检查** → 如果失败，退出并说明原因
2. **测试状态检查** → 如果失败，退出并说明原因
3. **YAML一致性检查** → 如果发现不一致，继续到步骤2进行修复
4. **单项测试执行** → 如果失败，退出并说明原因
5. **模板检查与创建** → 如果无法创建，退出并说明原因

##### 1.7 退出条件
- **代码编译失败**：如果代码无法编译，退出并说明具体错误
- **测试失败**：如果相关测试失败，退出并说明失败原因
- **YAML不一致且无法修复**：如果YAML与代码不一致且无法修复，退出并说明原因
- **模板缺失且无法创建**：如果没有匹配模板且无法创建，退出并说明原因
- **依赖问题**：如果存在无法解决的依赖问题，退出并说明原因

#### 2. 代码与YAML一致性核对
- **读取现有YAML**：检查相关YAML文档的当前内容
- **代码实现对比**：将当前代码实现与YAML文档进行对比
- **不一致项识别**：识别代码与YAML不一致的地方
- **YAML更新**：修改YAML文档确保与当前代码表现完全一致
- **一致性验证**：确认修改后的YAML与代码实现完全匹配

#### 3. 模板检查与创建

##### 3.1 YAML文件检查
- **现有YAML扫描**：扫描 `documents/` 下所有YAML文件
- **代码关联分析**：分析当前代码与现有YAML文件的关联关系
- **缺失文件识别**：识别缺少对应YAML文件的代码模块
- **关联度评估**：评估代码模块与YAML文件的关联度

##### 3.2 模板匹配检查
- **模板目录扫描**：检查 `documents/templates/` 下的所有模板文件
- **模板类型匹配**：根据代码类型匹配相应的模板
- **模板适用性评估**：评估模板是否适用于当前代码
- **模板完整性检查**：检查模板是否包含所有必需字段

##### 3.3 模板创建流程
- **模板选择**：选择最匹配的模板文件
- **字段填充**：根据当前代码实现填充模板字段
- **依赖关系分析**：分析代码的依赖关系和调用关系
- **YAML文件生成**：基于模板生成对应的YAML文件
- **文件位置确定**：确定YAML文件的正确存放位置

##### 3.4 模板缺失处理
- **缺失原因分析**：分析为什么没有匹配的模板
- **模板需求定义**：定义需要的模板类型和结构
- **用户通知**：通知用户需要生成模板
- **退出条件**：如果无法创建模板，退出preview流程

##### 3.5 模板格式建议
- **模板结构建议**：提供标准的模板结构建议
- **必需字段定义**：定义模板必须包含的字段
- **可选字段说明**：说明模板的可选字段和用途
- **示例模板**：提供完整的示例模板
- **最佳实践**：提供模板设计的最佳实践建议

#### 4. 上下文分析
- 根据之前的聊天上下文，判断是否需要生成迭代预览
- 评估讨论的成熟度和完整性
- 基于前置工作检查的结果进行需求分析

#### 5. 需求总结
- 总结本次迭代的需求和目标
- 提取关键需求点和约束条件
- 结合代码现状和YAML一致性分析

#### 6. 文档影响分析
- 确定哪些 `documents/` 下的 yaml 文件需要修改
- 找到具体需要修改的文件和修改点
- 明确修改的目的和原因
- 基于前置工作检查的结果进行影响分析

#### 7. Preview 文档生成
- 在 `documents/plan/` 下创建 `preview-yymmdd-id.yaml` 文档
- yymmdd 为当前系统日期（执行 `date +%y%m%d` 获取）
- id 为迭代编号（如 251024-1）
- **必须基于模板生成**：使用 `documents/templates/preview_template.yaml` 作为标准模板
- **模板字段完整性**：确保所有必需字段都已填写，包括调用关系、依赖关系等
- **基于前置工作**：确保preview文档基于前置工作检查的结果

### Plan 文档生成流程

#### 1. Preview 文档检查
- 检查 `documents/plan/` 下是否已存在对应的 preview 文档
- 如果不存在，自动执行 preview 生成流程

#### 2. Plan 文档创建
- 基于 `documents/templates/plan_template.yaml` 创建 `plan-yymmdd-id.yaml`
- **不再复制 preview 内容**，而是基于 preview 制定具体的实施计划

#### 3. 四大核心要素

**3.1 实现规范YAML生成/修改计划**
- 根据 preview 文档生成或修改对应的实现规范 YAML 文件
- 明确每个 YAML 文件的变更内容和来源
- 确保规范文件与 preview 设计保持一致

**3.2 验收测试用例计划**
- **区分现有测试修改和新测试创建**
- 对于现有测试：明确修改原因、当前期望、新期望
- 对于新测试：定义测试类型、期望结果、实现代码
- **配置相关测试**：验证文字、theme、环境变量等不是硬编码
  - 必须读取对应的 YAML 文件进行验证
  - 确保配置值与实现规范 YAML 一致

**3.3 实现代码计划**
- 具体的代码实现步骤
- 文件创建/修改计划
- 依赖关系管理

**3.4 执行状态跟踪**
- 类似 todolist 的状态管理
- 记录当前进展到哪个环节
- 支持重试机制（最多3次）
- 跳过时记录详细的问题分析和解决尝试

#### 4. 执行状态管理

**4.1 状态定义**
- `pending`: 等待执行
- `in_progress`: 正在执行
- `completed`: 成功完成
- `failed`: 执行失败
- `skipped`: 跳过（重试3次后仍失败）

**4.2 阶段划分**
- `yaml_updates`: 更新实现规范YAML文件
- `testing`: 创建/修改测试用例
- `implementation`: 实现代码
- `validation`: 验证实现

**4.3 重试机制**
- 每个任务最多重试3次
- 记录每次重试的解决方式和失败表现
- 排除已尝试的可能性

**4.4 跳过记录**
- 记录跳过原因
- 详细记录三次解决尝试
- 分析失败表现和排除的可能性
- 提供最终结论

### 文档位置规范

#### 文件夹结构
```
documents/
├── spec/           # 规格文档
│   ├── product_requirements.yaml    # 产品需求规格
│   ├── user_stories.md             # 用户故事
│   ├── *-技术规范.yaml             # 技术规范文档
│   └── iteration_template.yaml     # 迭代模板
├── config/         # 配置文档
│   ├── theme.yaml                  # 主题配置
│   ├── config.yaml                 # 环境配置
│   ├── l10n.yaml                   # 本地化配置
│   └── analysis_options.yaml       # 代码分析配置
├── architecture/   # 架构文档
│   ├── models.yaml                 # 数据模型
│   ├── pages.yaml                  # 页面结构
│   ├── providers.yaml              # 状态管理
│   ├── services.yaml               # 业务服务
│   ├── widgets.yaml                # 组件定义
│   └── routers.yaml                # 路由配置
├── project/        # 项目管理文档
│   ├── project_plan.yaml           # 项目计划
│   ├── PROGRESS.md                 # 项目进度
│   ├── rules.yaml                  # 项目规则
│   ├── refactor_rules.yaml         # 重构规则
│   ├── todo-list.yaml              # 任务列表
│   └── kpi_overview.md             # KPI概览
├── plan/           # 迭代计划文档
│   ├── *-preview.yaml              # 迭代预览
│   └── *-plan.yaml                 # 详细计划
├── deployment/     # 部署相关文档
│   ├── go_live_report.md           # 上线报告
│   ├── launch_checklist.md         # 发布清单
│   └── storage_migrations.md       # 数据迁移
├── legal/          # 法律文档
│   ├── privacy_policy.md           # 隐私政策
│   └── terms_of_service.md         # 服务条款
├── test_reports/   # 测试报告
│   └── offline_validation.md       # 离线验证报告
└── temp/           # 临时备份文件夹
    └── *.yaml.backup               # YAML文件备份
```

#### 文档职责分工
- **spec/**: 定义"做什么" - 产品需求、用户故事、技术规范
- **config/**: 定义"如何配置" - 主题、环境、本地化、代码规范
- **architecture/**: 定义"如何构建" - 组件、数据流、状态管理
- **project/**: 定义"如何管理" - 计划、进度、规则、KPI
- **plan/**: 定义"如何执行" - 迭代预览和详细计划
- **deployment/**: 定义"如何部署" - 上线、迁移、发布
- **legal/**: 定义"法律合规" - 隐私、服务条款
- **test_reports/**: 记录"测试结果" - 验证报告
- **temp/**: 临时备份存储 - YAML文件修改前的备份

### 文档格式规范

#### Step 模板使用规则

##### 模板文件位置
- 标准模板：`documents/templates/step_template.yaml`
- 所有 step 文档必须基于此模板生成
- 模板专注于代码实现，不包含YAML和测试内容

##### 模板字段要求
- **meta 部分**：版本、类型、迭代号、基于的preview文档
- **execution_status 部分**：执行状态跟踪
  - 状态管理（pending/in_progress/completed/failed）
  - 阶段划分（analysis/implementation/verification）
  - 重试机制（最多3次）
  - 跳过记录（详细的问题分析）
- **implementation_plan 部分**：基于preview文档的代码实现计划
  - `new_files`: 需要创建的新文件
  - `modified_files`: 需要修改的现有文件
  - `dependencies`: 需要添加的依赖包
- **code_changes 部分**：具体的代码变更内容
- **verification_plan 部分**：代码验证计划
  - `compilation_check`: 编译检查
  - `basic_functionality`: 基本功能验证
  - `integration_check`: 集成检查
- **success_criteria 部分**：成功标准

##### 模板使用原则
- **基于preview设计**：所有代码实现必须严格按照preview文档设计
- **不包含YAML和测试**：step专注于代码实现，不涉及规范文件和测试
- **用户测试确认**：代码实现完成后必须等待用户手工测试
- **step-done补充**：用户测试通过后执行step-done才补充YAML和测试
- **状态跟踪完整**：实时更新执行状态，记录每个环节的进展

#### Plan 模板使用规则

##### 模板文件位置
- 标准模板：`documents/templates/plan_template.yaml`
- 所有 plan 文档必须基于此模板生成
- 模板定义了四大核心要素和完整的执行跟踪机制

##### 模板字段要求
- **yaml_specification_updates 部分**：实现规范YAML生成/修改计划
  - 明确每个YAML文件的变更内容和来源
  - 基于preview文档的具体设计
- **testing_plan 部分**：验收测试用例计划
  - `existing_tests`: 需要修改的现有测试用例
  - `new_tests`: 需要新建的测试用例
  - `configuration_tests`: 配置相关测试（验证无硬编码）
- **implementation_plan 部分**：实现代码计划
  - 具体的代码实现步骤
  - 文件创建/修改计划
  - 依赖关系管理
- **execution_tracking 部分**：执行状态跟踪
  - 状态管理（pending/in_progress/completed/failed/skipped）
  - 阶段划分（yaml_updates/testing/implementation/validation）
  - 重试机制（最多3次）
  - 跳过记录（详细的问题分析和解决尝试）

##### 模板使用原则
- **不复制preview内容**：plan专注于具体实施，不重复preview的设计内容
- **基于preview制定计划**：所有计划都基于preview文档的具体设计
- **状态跟踪完整**：类似todolist的状态管理，记录每个环节的进展
- **重试机制完善**：每个任务最多重试3次，记录详细的问题分析
- **跳过记录详细**：记录三次解决尝试、失败表现和排除的可能性

#### Preview 模板使用规则

##### 模板文件位置
- 标准模板：`documents/templates/preview_template.yaml`
- 所有 preview 文档必须基于此模板生成
- 模板定义了完整的文档结构和必需字段

##### 模板字段要求
- **meta 部分**：包含版本、类型、迭代号、生成时间
- **summary 部分**：目标描述和需求列表
- **component_design_states 部分**：复杂状态设计说明（可选）
- **new_files 部分**：新建文件的详细设计，必须包含：
  - 完整的属性定义
  - 子组件结构
  - 方法定义
  - 依赖关系
  - 调用关系（`called_by` 和 `calls`）
- **modified_files 部分**：修改文件的详细差异，必须包含：
  - 当前结构 vs 新结构对比
  - 属性变更详情
  - 实现变更说明
  - 调用关系（`called_by` 和 `calls`）
- **architecture_updates 部分**：架构文档更新
- **testing_strategy 部分**：测试策略
- **success_criteria 部分**：成功标准

##### 模板使用原则
- **完整性**：所有必需字段都必须填写，不能留空
- **一致性**：调用关系必须准确反映文件间的依赖
- **可执行性**：文档应可作为完整的设计稿，支持代码生成
- **标准化**：遵循模板定义的格式和结构

#### YAML文件备份规则

##### 备份触发条件
- 在todolist和step流程中，**第一次修改**任何`documents/`下的YAML文件时
- 必须在修改前创建备份，确保可以回滚

##### 备份文件命名规则
- 格式：`原文件名.yymmdd-hhiiss.yaml.backup`
- 示例：`theme.yaml.251024-143052.yaml.backup`
- 时间戳格式：年月日-时分秒（24小时制）

##### 备份存储位置
- 统一存储在 `documents/temp/` 文件夹
- 该文件夹已加入`.gitignore`，不会提交到版本控制
- 已配置`.cursorignore`，确保Cursor可以正常读写备份文件
- 备份文件按时间戳排序，便于查找

##### 备份执行流程
1. **检查备份需求**：确认是否为第一次修改该YAML文件
2. **创建temp目录**：如果不存在则创建 `documents/temp/` 文件夹
3. **生成时间戳**：执行 `date +%y%m%d-%H%M%S` 获取当前时间戳
4. **创建备份**：复制原文件到temp目录，使用新的命名规则
5. **执行修改**：在备份完成后进行实际的YAML文件修改
6. **记录备份**：在相关文档中记录备份文件路径和修改原因

##### 备份管理
- **自动清理**：建议定期清理超过30天的备份文件
- **版本追踪**：重要修改的备份应长期保留
- **回滚支持**：提供基于备份文件的快速回滚机制

#### Preview 文档格式
- **必须使用标准模板**：基于 `documents/templates/preview_template.yaml` 生成
- **模板字段要求**：
  - 所有 `new_files` 必须包含完整的 `called_by` 和 `calls` 字段
  - 所有 `modified_files` 必须包含完整的 `called_by` 和 `calls` 字段
  - 必须包含 `component_design_states` 部分（如果涉及复杂状态设计）
  - 必须包含 `testing_strategy` 和 `success_criteria` 部分
- **文档完整性**：确保文档可以作为完整的设计稿，支持从规范到代码的完整转换流程

#### Plan 文档格式
- **必须使用标准模板**：基于 `documents/templates/plan_template.yaml` 生成
- **不再复制 preview 内容**：专注于具体的实施计划
- **四大核心要素**：
  1. `yaml_specification_updates`: 实现规范YAML生成/修改计划
  2. `testing_plan`: 验收测试用例计划（区分现有测试修改和新测试创建）
  3. `implementation_plan`: 实现代码计划
  4. `execution_tracking`: 执行状态跟踪（类似todolist）

#### 模板字段要求
- **yaml_specification_updates**: 明确每个YAML文件的变更内容和来源
- **testing_plan**: 
  - `existing_tests`: 需要修改的现有测试用例
  - `new_tests`: 需要新建的测试用例
  - `configuration_tests`: 配置相关测试（验证无硬编码）
- **implementation_plan**: 具体的代码实现步骤和依赖关系
- **execution_tracking**: 
  - 状态管理（pending/in_progress/completed/failed/skipped）
  - 阶段划分（yaml_updates/testing/implementation/validation）
  - 重试机制（最多3次）
  - 跳过记录（详细的问题分析和解决尝试）

### 质量保证机制

#### 准确性要求
- Preview内容必须准确反映聊天上下文
- Plan内容必须准确指导实施过程

#### 完整性要求
- 不能遗漏重要的需求点和影响文件
- 测试覆盖必须完整，包括边界情况

#### 可执行性要求
- 生成的文档应可作为实施的直接依据
- 每个步骤都有明确的验证标准

#### 一致性要求
- 与现有文档结构保持一致
- 遵循项目的命名和组织规范

### 测试失败处理原则

#### 核心原则
- **测试失败 = 修复代码**，而非修改测试来适应代码
- **Preview优先**: preview文档定义了需要修改的内容和方式
- **原yaml同步**: 在开始代码修改前，原yaml文档应已按照preview要求更新
- **分层约束**: preview涉及的修改部分以preview为准，未涉及部分以原yaml为准

#### 执行前提
- **文档同步**: 原yaml文档必须在代码修改前按照preview要求完成更新
- **持续迭代**: 原yaml文档随项目发展不断更新，始终反映当前代码状态
- **Plan阶段性**: Plan文档仅为当前迭代的实施指导，会在迭代完成后归档
- **冲突检查**: 如果发现preview与原yaml冲突，说明文档更新不完整，应先修复文档
- **实施顺序**: Preview生成 → 原文档更新 → 代码实现 → 测试验证

#### 修复优先级
1. **检查文档同步**: 确认原yaml是否已按preview要求更新
2. **修复文档遗漏**: 如果发现冲突，优先按照preview要求更新原文档
3. **修复代码实现**: 在文档正确的前提下修改代码通过测试
4. **验证一致性**: 确保修改符合preview定义的变更范围

#### 放弃修改条件
- **Preview违背**: 修改将显著偏离preview定义的设计意图
- **原文档冲突**: 即使按preview更新，仍与项目整体设计理念冲突
- **技术不可行**: 现有技术栈无法实现preview定义的需求
- **风险过高**: 修改可能引入严重副作用或破坏现有功能

#### 报告要求
- **详细分析**: 说明测试失败的具体原因和文档状态
- **同步检查**: 确认是否所有相关文档都已按preview要求更新
- **修复路径**: 说明是代码问题还是文档同步问题
- **执行状态**: 如需中断，明确标识并说明原因

### 异常处理规范

#### 上下文不足
- 如果聊天上下文不够清晰，无法生成准确预览/计划，应请求用户澄清具体需求

#### 需求冲突
- 如果发现需求冲突，应在文档中明确指出并建议解决方案

#### 范围过大
- 如果影响范围过大，应建议拆分为多个独立的迭代
- 或按优先级分阶段实施

#### 测试失败
- 遵循上述"测试失败处理原则"
- 优先检查代码实现是否符合设计文档
- 如无法修复，执行放弃修改流程

### 执行优先级

1. **高优先级**: 单文件修改任务
2. **中优先级**: 多文件相关修改（完成后统一测试）
3. **低优先级**: 文档和配置更新任务

### 文档生命周期管理

#### 原yaml文档
- **持续迭代**: 随项目发展不断更新，始终反映当前代码状态
- **权威参考**: 测试验证时应读取这些文档的内容
- **长期维护**: 作为项目的基础设计文档，长期保存

#### Plan相关文档
- **阶段性**: 仅为当前迭代的实施指导
- **执行后归档**: 迭代完成后移至归档目录
- **参考价值**: 可作为未来类似任务的参考模板

## Todo 机制规则

### Todo 触发条件
- 当用户在聊天中提到"todo"时，AI必须判断是否需要创建任务清单来跟踪迭代进度
- Todo可作为Preview/Plan的补充，用于跟踪具体的执行状态和进度管理

### Todo 文档生成流程

#### 1. 上下文分析
- 检查是否已有preview或plan文档
- 确定需要跟踪的任务范围和粒度
- 评估任务的复杂度和依赖关系

#### 2. Todo 文档创建
- 在 `documents/plan/` 下创建 `yymmdd-number-autotodo.yaml` 文档
- 继承现有plan文档的任务结构
- 添加执行状态跟踪和进度管理

#### 3. 自动化执行集成
- Todo文档可与自动化执行流程集成
- 自动更新任务状态和进度统计
- 支持失败任务的跳过和重试机制

### Todo 文档格式规范

```yaml
meta:
  version: 1
  type: autotodo
  iteration: "yymmdd-number"
  description: "自动化任务跟踪清单"
  auto_execution: true

tasks:
  - id: "TASK-1"
    description: "任务描述"
    status: "pending|in_progress|completed|skipped"
    auto_executable: true|false
    priority: "high|medium|low"
    dependencies: ["TASK-X", "TASK-Y"]
    execution_time: 0  # 实际执行时间（分钟）
    retry_count: 0     # 重试次数

progress_tracking:
  total_tasks: 0
  completed_tasks: 0
  skipped_tasks: 0
  in_progress_tasks: 0

  by_priority:
    high: 0
    medium: 0
    low: 0

execution_log:
  - timestamp: "YYYY-MM-DD HH:mm:ss"
    task_id: "TASK-1"
    action: "started|completed|skipped|failed"
    message: "执行详情或错误信息"
```

### Todo 执行规则

#### 状态管理
- **pending**: 等待执行
- **in_progress**: 正在执行（一次只允许一个任务in_progress）
- **completed**: 成功完成
- **skipped**: 根据规则跳过（如依赖失败、测试失败时跳过）

#### 依赖处理
- 自动检查任务依赖关系
- 依赖任务失败时，自动跳过后续依赖任务
- 支持并行执行无依赖关系的任务

#### 失败处理
- 遵循Plan文档中的测试失败处理原则
- 记录失败原因和上下文
- 支持自动重试机制（最多3次）

### 集成机制

#### 与Plan文档的关系
- Todo作为Plan的执行跟踪补充
- Plan定义"做什么"和"怎么做"
- Todo跟踪"做了什么"和"做得怎么样"

#### 与自动化执行的关系
- Todo可作为自动化执行的驱动脚本
- 每个任务的执行结果自动更新Todo状态
- 支持实时进度报告和最终总结

### 质量保证

- **一致性**: 与Plan文档的任务定义保持一致
- **实时性**: 任务状态及时更新
- **透明性**: 详细记录执行过程和结果
- **可追溯性**: 支持问题排查和过程回溯

## Step 机制规则

### Step 触发条件
- 当用户描述一个**具体的代码实现需求**时，AI必须按以下步骤执行
- Step适用于**基于preview文档的直接代码实现**，专注于功能实现，不涉及YAML和测试
- 用户手工测试通过后，执行step-done才补充规范YAML和对应测试

### Step 执行流程

#### 1. 需求分析
- 基于preview文档分析具体的代码实现需求
- 确定需要创建/修改的代码文件和实现点
- 评估实现复杂度和依赖关系

#### 2. Step 文档生成
- **基于preview文档生成** `documents/plan/yymmdd-number-step.yaml`
- 专注于代码实现计划，不包含YAML和测试内容
- 包含完整的代码实现步骤和执行计划

#### 3. 文档审阅
- **生成step文档后立即停止**，等待用户审阅
- 用户确认step文档正确后，再开始执行
- 支持用户修改或重新生成step文档

#### 4. 代码实现
- 获得用户确认后，**严格按Step文档执行代码实现**
- **每个步骤完成后验证代码编译和基本功能**
- **发现问题立即停止**，不继续执行
- **实现完成后等待用户手工测试**

#### 5. 用户测试确认
- 代码实现完成后，等待用户手工测试
- 用户测试通过后，执行step-done命令
- step-done将补充规范YAML和对应测试

### Step 文档格式规范

#### 必须使用标准模板
- 基于 `documents/templates/step_template.yaml` 生成
- 专注于代码实现，不包含YAML和测试内容
- 基于preview文档的具体设计

#### 核心字段要求
- **meta**: 版本、类型、迭代号、基于的preview文档
- **execution_status**: 执行状态跟踪（pending/in_progress/completed/failed）
- **implementation_plan**: 代码实现计划（基于preview设计）
- **code_changes**: 具体的代码变更内容
- **verification_plan**: 代码验证计划（编译、基本功能）
- **success_criteria**: 成功标准（代码实现、用户测试通过）

#### 模板字段说明
- **implementation_plan**: 基于preview文档的代码实现步骤
- **code_changes**: 
  - `new_files`: 需要创建的新文件
  - `modified_files`: 需要修改的现有文件
  - `dependencies`: 需要添加的依赖包
- **verification_plan**: 
  - `compilation_check`: 编译检查
  - `basic_functionality`: 基本功能验证
  - `integration_check`: 集成检查
- **execution_tracking**: 
  - 状态管理（pending/in_progress/completed/failed）
  - 步骤划分（analysis/implementation/verification）
  - 重试机制（最多3次）
  - 跳过记录（详细的问题分析）

### Step-Done 触发条件
- 当用户执行"step-done"命令时，AI必须按以下步骤执行
- Step-Done适用于**代码实现完成且用户手工测试通过后**的后续工作
- 补充规范YAML文件和对应测试用例

### Step-Done 执行流程

#### 1. 确认代码实现状态
- 检查当前step文档的执行状态
- 确认代码实现已完成
- 确认用户手工测试已通过

#### 2. 补充规范YAML文件
- 根据step文档中的代码实现，生成对应的规范YAML文件
- 更新架构文档中的相关组件定义
- 确保YAML文件与代码实现一致

#### 3. 创建对应测试用例
- 根据代码实现创建单元测试
- 根据代码实现创建组件测试
- 根据代码实现创建集成测试

#### 4. 运行测试验证
- 运行所有新创建的测试用例
- 确保测试通过
- 更新测试覆盖率

#### 5. 自动提交处理
- 读取git logs判断上次提交时间
- 如果未超过半小时：执行pre-commit确保通过
- 如果超过半小时：直接git commit提交
- 提交失败时：检查错误并重试（最多5次）
- 记录所有错误到plane-logs目录

#### 6. 错误处理和重试机制
- 使用 `documents/templates/git_commit_helper.py` 处理git提交
- 使用 `documents/templates/error_logging_helper.py` 记录错误日志
- 错误日志格式：JSON格式，包含报错内容、估计原因、解决方式、失败表现、排除可能
- 最多重试5次，超过自动退出
- 所有错误日志保存到 `documents/plan-logs` 目录

#### 7. Step-Done 执行器
- 使用 `documents/templates/step_done_executor.py` 执行完整流程
- 自动执行：YAML更新 → 测试创建 → 验证 → Git提交
- 支持错误处理和重试机制
- 使用方法：`python documents/templates/step_done_executor.py <step_done_file>`

#### 8. Plan 执行器
- 使用 `documents/templates/plan_executor.py` 执行完整流程
- 自动执行：YAML更新 → 测试创建 → 代码实现 → 验证 → pre-commit检查
- 支持错误处理和重试机制（最多3次）
- 错误日志记录到 `documents/plan-logs` 目录
- 使用方法：`python documents/templates/plan_executor.py <plan_file>`

#### 9. 错误日志记录规则
- 所有执行器都使用 `documents/plan-logs` 目录记录错误
- 日志格式：JSON格式，包含中文错误描述
- 记录内容：报错内容、估计原因、解决方式、失败表现、排除可能
- 重试跟踪：记录每次重试的详细过程
- 自动退出：达到最大重试次数后自动退出

### Step-Done 文档格式规范

#### 必须包含的字段
- **meta**: 版本、类型、迭代号、基于的step文档
- **yaml_updates**: 规范YAML文件更新计划
- **test_creation**: 测试用例创建计划
- **verification**: 验证计划
- **execution_tracking**: 执行状态跟踪

#### 模板字段要求
- **yaml_updates**: 根据代码实现生成/修改规范YAML文件
- **test_creation**: 
  - `unit_tests`: 单元测试创建
  - `widget_tests`: 组件测试创建
  - `integration_tests`: 集成测试创建
- **verification**: 
  - `yaml_consistency`: YAML文件一致性验证
  - `test_execution`: 测试执行验证
  - `coverage_check`: 覆盖率检查
- **git_commit_handling**: 
  - `time_check`: 检查上次提交时间
  - `pre_commit_check`: pre-commit验证（未超过半小时）
  - `direct_commit`: 直接提交（超过半小时）
  - `error_handling`: 错误处理和重试机制
- **execution_tracking**: 
  - 状态管理（pending/in_progress/completed/failed）
  - 阶段划分（yaml_updates/test_creation/verification/git_commit）
  - 重试机制（最多3次）
  - 错误日志记录（最多5次重试）

### Step 执行原则

#### 性能优化原则
- **限制并行操作**: 单次最多同时调用3个工具，避免系统过载
- **分批处理**: 对于多文件修改，按文件分组分批执行
- **状态同步**: 执行前检查状态，执行后立即更新状态，避免重复验证
- **超时控制**: 单个工具调用不超过30秒，避免无限等待
- **重试机制**: 失败时最多重试2次，每次间隔5秒
- **进度报告**: 每完成一个步骤主动报告进度，避免用户等待焦虑
- **循环检测**: 检测重复的工具调用，如果连续3次相同调用则停止并报告错误

#### 范围控制
- **单一需求**: 只处理用户提到的一个具体变化
- **最小修改**: 不进行额外的优化或重构
- **精确执行**: 严格按照Step文档执行，不发挥创造性

#### 质量保证
- **逐步验证**: 每个步骤完成后必须验证
- **立即停止**: 发现问题立即停止，不继续执行
- **完整回滚**: 失败时有明确的回滚计划

#### 文档管理
- **Step文档**: 整合Preview和Plan的内容
- **自动生成**: 无需手动创建autotodo等额外文档
- **版本控制**: 按日期和编号命名

### 适用场景

#### ✅ 适合使用Step的情况
- 修改按钮颜色
- 调整文字大小
- 更改图标样式
- 添加简单功能
- 修复小bug

#### ❌ 不适合使用Step的情况
- 架构重构
- 多模块修改
- 复杂功能开发
- 需要全面测试的修改

### 执行优先级

1. **需求分析** (分析用户需求)
2. **生成Step文档** (制定计划)
3. **用户审阅确认** (等待用户确认step文档)
4. **按步骤执行** (逐步修改，执行时更新状态)
5. **状态更新** (每个步骤完成后立即更新execution_status)
6. **验证测试** (确保正确)
7. **用户验收** (确认满意)

#### 状态管理要求
- **开始执行前**: 将 overall_status 设为 "in_progress"
- **每个步骤开始**: 将 current_step 设为当前步骤ID，步骤status设为 "in_progress"
- **步骤完成**: 将步骤status设为 "completed"，添加到 completed_steps 列表
- **步骤失败**: 将步骤status设为 "failed"，添加到 failed_steps 列表
- **全部完成**: 将 overall_status 设为 "completed"
- **执行中断**: 记录 current_step 和失败原因

#### 优化后的执行流程
1. **准备阶段**: 读取step文档，检查execution_status，确认从哪个步骤开始
2. **分批执行**: 按文件分组，每次最多修改3个文件
3. **实时反馈**: 每个步骤完成后立即更新状态并报告进度
4. **异常处理**: 遇到问题立即停止，不继续执行，避免级联错误
5. **状态持久化**: 每完成一个步骤都保存状态，避免重复工作

### 最终成果验证

参考 `documents/plan/` 下的现有文档作为质量标准：
- **文件夹结构**: 遵循 `documents/README.md` 中定义的分类规范
- **Preview文档**: `documents/plan/251024-1-preview.yaml` 作为格式标准
- **Plan文档**: `documents/plan/251024-1-plan.yaml` 作为格式标准
- **文档同步**: 确保相关文档按文件夹分类正确存放

## 规则执行优先级

### 1. Chat 规则（最高优先级）
- 当用户输入"chat"时，立即进入讨论模式
- 不执行任何文件修改，专注于需求分析
- 为后续规则提供完整的上下文信息

### 2. Preview 规则
- **前置工作检查**：执行完整的代码、测试、YAML一致性检查
- **基于Chat的讨论内容**：生成迭代预览
- **分析文档影响和修改范围**：基于前置工作检查结果
- **为Plan规则提供基础**：确保preview基于稳定的代码基础

### 3. Plan 规则  
- 基于Preview内容制定详细实施计划
- 包含完整的测试策略和验证方法
- 为Step规则提供执行指导

### 4. Step 规则
- 基于Plan内容执行精确的代码修改
- 严格按步骤执行，逐步验证
- 支持回滚和错误处理

### 5. Todo 规则
- 作为其他规则的补充，用于进度跟踪
- 支持自动化执行和状态管理
- 提供详细的执行日志和报告